From 0ab3bc38f14e920983705a185a231b5ca832673e Mon Sep 17 00:00:00 2001
From: hernan <hrnn.rodriguez@gmail.com>
Date: Thu, 1 Jun 2017 14:22:17 -0300
Subject: [PATCH 1/1] Support for HW BombShell_V2

---
 arch/arm/boot/dts/imx7dea-ucom-kit-lvds.dts |   54 +-
 arch/arm/boot/dts/imx7dea-ucom-kit-m4.dts   |    1 +
 arch/arm/boot/dts/imx7dea-ucom-kit.dts      |  970 +++++++++++++++++++
 arch/arm/configs/imx_v7_defconfig           |    4 +
 arch/arm/configs/mx7dea-ucom_defconfig      |  440 ++++++++
 drivers/hwmon/Kconfig                       |    9 +
 drivers/hwmon/Makefile                      |    1 +
 drivers/hwmon/tps6518x-hwmon.c              |  331 ++++++
 drivers/input/touchscreen/Kconfig           |   12 +
 drivers/input/touchscreen/Makefile          |    1 +
 drivers/input/touchscreen/ektf2k_5B.c       | 1478 +++++++++++++++++++++++++++
 drivers/mfd/Kconfig                         |    7 +
 drivers/mfd/Makefile                        |    1 +
 drivers/mfd/tps6518x-core.c                 |  304 ++++++
 drivers/regulator/Kconfig                   |    4 +
 drivers/regulator/Makefile                  |    1 +
 drivers/regulator/tps6518x-regulator.c      |  890 ++++++++++++++++
 drivers/video/fbdev/mxc/mxc_epdc_v2_fb.c    |    5 +-
 include/linux/earlysuspend.h                |   52 +
 include/linux/ektf2k.h                      |   34 +
 include/linux/mfd/tps6518x.h                |  357 +++++++
 21 files changed, 4207 insertions(+), 111 deletions(-)
 create mode 100644 arch/arm/boot/dts/imx7dea-ucom-kit-lvds.dts
 create mode 100644 arch/arm/boot/dts/imx7dea-ucom-kit-m4.dts
 create mode 100644 arch/arm/boot/dts/imx7dea-ucom-kit.dts
 create mode 100644 arch/arm/configs/mx7dea-ucom_defconfig
 create mode 100644 drivers/hwmon/tps6518x-hwmon.c
 create mode 100644 drivers/input/touchscreen/ektf2k_5B.c
 create mode 100644 drivers/mfd/tps6518x-core.c
 create mode 100644 drivers/regulator/tps6518x-regulator.c
 create mode 100644 include/linux/earlysuspend.h
 create mode 100644 include/linux/ektf2k.h
 create mode 100644 include/linux/mfd/tps6518x.h

diff --git a/arch/arm/boot/dts/imx7dea-ucom-kit-lvds.dts b/arch/arm/boot/dts/imx7dea-ucom-kit-lvds.dts
index cd69c0b..76a5ace 100644
--- a/arch/arm/boot/dts/imx7dea-ucom-kit-lvds.dts
+++ b/arch/arm/boot/dts/imx7dea-ucom-kit-lvds.dts
@@ -21,7 +21,7 @@
 
 
 &i2c1 {
-    ar1021_rgb {
+/*    ar1021_rgb {
 	pinctrl-0 = <&pinctrl_lvds0>;
 	interrupt-parent = <&gpio2>;
 	interrupts = <26 IRQ_TYPE_EDGE_FALLING>;
@@ -33,7 +33,7 @@
 	interrupt-parent = <&gpio2>;
 	interrupts = <26 IRQ_TYPE_EDGE_FALLING>;
 	wakeup-gpios = <&gpio2 26 GPIO_ACTIVE_HIGH>;
-	status = "okay";
+	status = "disabled";//"okay";
     };
 
     edt-ft5x06_rgb {
@@ -56,18 +56,52 @@
 	interrupts = <26 IRQ_TYPE_EDGE_FALLING>;
 	status = "disabled";
     };
+*/
 };
-
+/*
 &t_lcd {
-	clock-frequency = <65000000>;
+        clock-frequency = <65000000>;
         hactive = <1024>;
         vactive = <768>;
-	hback-porch = <220>;
-	hfront-porch = <40>;
-	vback-porch = <21>;
-	vfront-porch = <7>;
-	hsync-len = <60>;
-	vsync-len = <10>;
+        hback-porch = <220>;
+        hfront-porch = <40>;
+        vback-porch = <21>;
+        vfront-porch = <7>;
+        hsync-len = <60>;
+        vsync-len = <10>;
+};
+*/
+&qspi1 {
+		status = "disabled";
+
+	flash0 {
+		status = "disabled";
+	};
+};
+
+&epdc {
+        status = "okay";
+};
+
+&fec1 {
+	status = "disabled";
+};
+
+&fec2 {
+	status = "disabled";
+};
+
+
+&flexcan1 {
+	status = "disabled";
+};
+
+&flexcan2 {
+	status = "disabled";
+};
+
+&tps6518x {
+        status = "okay";
 };
 
 &backlight_lcd {
diff --git a/arch/arm/boot/dts/imx7dea-ucom-kit-m4.dts b/arch/arm/boot/dts/imx7dea-ucom-kit-m4.dts
index 78a58f7..21495f8 100644
--- a/arch/arm/boot/dts/imx7dea-ucom-kit-m4.dts
+++ b/arch/arm/boot/dts/imx7dea-ucom-kit-m4.dts
@@ -59,3 +59,4 @@
 &wdog3{
 	status = "disabled";
 };
+
diff --git a/arch/arm/boot/dts/imx7dea-ucom-kit.dts b/arch/arm/boot/dts/imx7dea-ucom-kit.dts
index 82b477c..58a1d81 100644
--- a/arch/arm/boot/dts/imx7dea-ucom-kit.dts
+++ b/arch/arm/boot/dts/imx7dea-ucom-kit.dts
@@ -17,14 +17,14 @@
 
 	/* Aliases to allow u-boot to modify the device tree */
 	aliases {
-		fb_rgb = &lcdif;
-		t_rgb = &t_lcd;
-		bl_rgb = &backlight_lcd;
-		rgb = &display0;
+		//fb_rgb = &epdc;//&lcdif;
+		//t_rgb = &t_lcd; //&epdc0;
+		//bl_rgb = &backlight_lcd;
+		//rgb = &epdc;//&display0; //&epdc0;
 		ts_con_rgb = &i2c1;
 	};
 
-	memory {
+ 	memory {
 		reg = <0x80000000 0x80000000>;
 	};
 
@@ -112,7 +112,7 @@
 			enable-active-high;
 		};
 	};
-
+/*
         sound {
                 compatible = "fsl,imx-audio-wm8731";
                 model = "wm8731-audio";
@@ -122,8 +122,31 @@
                 audio-codec = <&codec>;
                 audio-routing = "LOUT", "ROUT", "LLINEIN", "RLINEIN";
         };
+/* added 
+	spi4 {
+		compatible = "spi-gpio";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_spi1>;
+		status = "okay";
+		gpio-sck = <&gpio1 13 0>;
+		gpio-mosi = <&gpio1 9 0>;
+		cs-gpios = <&gpio1 12 0>;
+		num-chipselects = <1>;
+		#address-cells = <1>;
+		#size-cells = <0>;
 
+	/*gpio_spi: gpio_spi@0 {
+			compatible = "fairchild,74hc595";
+			gpio-controller;
+			#gpio-cells = <2>;
+			reg = <0>;
+			registers-number = <1>;
+			registers-default = /bits/ 8 <0x54>; /* Enable PERI_3V3, SENSOR_RST_B and HDMI_RST*/
+		//	spi-max-frequency = <100000>;
+		//};
 
+	//};
+/* */
 };
 
 &adc1 {
@@ -144,7 +167,7 @@
 &cpu0 {
 	arm-supply = <&buck1_reg>;
 };
-
+/*
 &csi1 {
 	csi-mux-mipi = <&gpr 0x14 4>;
 	status = "okay";
@@ -155,12 +178,22 @@
 		};
 	};
 };
+*/
+&epdc {
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_epdc0>;
+        V3P3-supply = <&V3P3_reg>;
+        VCOM-supply = <&VCOM_reg>;
+        DISPLAY-supply = <&DISPLAY_reg>;
+		//en-gpios = <&gpio_spi 5 0>;
+        status = "okay";
+};
 
 &epxp {
 	status = "okay";
 };
 
-
+/*
 &fec1 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_enet1>;
@@ -172,7 +205,7 @@
 	phy-mode = "rgmii";
 	phy-handle = <&ethphy0>;
 	fsl,magic-packet;
-	status = "okay";
+	status = "disabled";//"okay";
 
 	mdio {
 		#address-cells = <1>;
@@ -184,27 +217,27 @@
 		};
 	};
 };
-
+*/
 
 &flexcan1 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_flexcan1>;
 	xceiver-supply = <&reg_can2_3v3>;
-	trx-stby-gpio = <&gpio2 23 GPIO_ACTIVE_LOW>;
-	status = "okay";
+	trx-en-gpio = <&gpio2 23 GPIO_ACTIVE_LOW>;
+	status = "disabled";//"okay";
 };
 
 &flexcan2 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_flexcan2>;
 	xceiver-supply = <&reg_can2_3v3>;
-	trx-stby-gpio = <&gpio2 23 GPIO_ACTIVE_LOW>;
-	status = "okay";
+	trx-en-gpio = <&gpio2 23 GPIO_ACTIVE_LOW>;
+	status = "disabled";//"okay";
 };
-
+/*
 &mipi_csi {
 	clock-frequency = <240000000>;
-	status = "okay";
+	status = "disabled";//"okay";   //////here..
 	port {
 		mipi_sensor_ep: endpoint1 {
 			remote-endpoint = <&ov5647_mipi_ep>;
@@ -218,7 +251,7 @@
 		};
 	};
 };
-
+*/
 &i2c1 {
 	clock-frequency = <100000>;
 	pinctrl-names = "default";
@@ -390,13 +423,12 @@
 		};
 	};
 
-	at24@55 {
-		compatible = "at,24c64";
-		pagesize = <32>;
-		reg = <0x55>;
-	};
-
-
+        at24@55 {
+                compatible = "at,24c64";
+                pagesize = <32>;
+                reg = <0x55>;
+        };
+/*
         ov5647_mipi: ov5647_mipi@36 {
                 compatible = "ovti,ov5647_mipi";
                 reg = <0x36>;
@@ -421,9 +453,9 @@
                 reg = <0x1a>;
                 clocks = <&clks IMX7D_AUDIO_MCLK_ROOT_CLK>;
         };
-
+*/
         /* AR1021 touch controller through RGB display interface connector on Carrier Board */
-        ar1021_rgb {
+/*        ar1021_rgb {
                 compatible = "microchip,ar1021-i2c";
                 reg = <0x4d>;
                 pinctrl-names = "default";
@@ -436,7 +468,7 @@
         };
 
         /* eGalax touch controller through RGB display interface connector on Carrier Board */
-        egalax_ts_rgb {
+/*        egalax_ts_rgb {
                 compatible = "eeti,egalax_ts";
                 reg = <0x04>;
                 pinctrl-names = "default";
@@ -448,38 +480,40 @@
         };
 
         /* FocalTech touch controller through RGB display interface connector on Carrier Board */
-        edt-ft5x06_rgb {
+/*        edt-ft5x06_rgb {
                 compatible = "edt,edt-ft5x06";
                 reg = <0x38>;
                 pinctrl-names = "default";
                 pinctrl-0 = <&pinctrl_rgb_connector>;
                 interrupt-parent = <&gpio5>;
                 interrupts = <9 IRQ_TYPE_EDGE_FALLING>;
-		reset-gpios = <&gpio2 27 GPIO_ACTIVE_HIGH>;
+                reset-gpios = <&gpio2 27 GPIO_ACTIVE_HIGH>;
                 status = "disabled";
         };
 
         /* Ilitek touch controller through RGB display interface connector on Carrier Board */
-        ilitek_aim_rgb {
+ /*       ilitek_aim_rgb {
                 compatible = "ilitek,ilitek_aim";
                 reg = <0x41>;
                 pinctrl-names = "default";
                 pinctrl-0 = <&pinctrl_rgb_connector>;
                 interrupt-parent = <&gpio5>;
                 interrupts = <9 IRQ_TYPE_EDGE_FALLING>;
-		reset-gpios = <&gpio2 27 GPIO_ACTIVE_HIGH>;
-		status = "disabled";
+                reset-gpios = <&gpio2 27 GPIO_ACTIVE_HIGH>;
+                status = "disabled";
         };
 
         /* Sitronix touch controller through RGB display interface connector on Carrier Board */
-        sitronix_rgb {
+ /*       sitronix_rgb {
                 compatible = "sitronix,sitronix_i2c";
                 reg = <0x55>;
                 pinctrl-names = "default";
                 pinctrl-0 = <&pinctrl_rgb_connector>;
                 interrupt-parent = <&gpio5>;
                 interrupts = <9 IRQ_TYPE_EDGE_FALLING>;
-        };
+                reset-gpios = <&gpio2 27 GPIO_ACTIVE_HIGH>;
+                status = "disabled";
+        };  */
 };
 
 &i2c2 {
@@ -487,6 +521,32 @@
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_i2c2>;
 	status = "okay";
+	/* elan-touch ektf2232-driver */  
+/*	elan@15 { 
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_epdc_elan_touch>;
+		compatible = compatible = "elan,elan-ktf2k";
+		reg = <0x15>; 
+		interrupt-parent = <&gpio7>;  
+		interrupts = <7 7>;	//<10 2>;
+		gpio_elan_cs = <&gpio1 2 0>;	//<&gpio2 9 0>;  //GPIO1_IO02 -> CE   <&gpio1 2 0>;
+		gpio_elan_rst = <&gpio1 3 0>; 	//<&gpio4 4 0>; //GPIO1_IO03 -> RESET <&gpio1 3 0>; 
+		gpio_intr = <&gpio7 7 0>;	  //ENET1_TD1  -> (INTERRUP MX7D_PAD_ENET1_RGMII_TD1__GPIO7_IO7)
+		status = "okay"; //ENABLE_TOUCH -> GPIO1_IO04 (mosfet) (jumper permanente)
+	};
+	/* elan-touch */
+	elan@10 {  
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_epdc_elan_touch>;
+		compatible = "elan,elan-touch";
+		reg = <0x10>; 
+		interrupt-parent = <&gpio7>; 
+		interrupts = <7 7>;	
+		gpio_elan_cs = <&gpio1 2 0>;	//<&gpio2 9 0>;  //GPIO1_IO02 -> CE   <&gpio1 2 0>;
+		gpio_elan_rst = <&gpio1 3 0>; 	//<&gpio4 4 0>; //GPIO1_IO03 -> RESET <&gpio1 3 0>; 
+		gpio_intr = <&gpio7 7 0>;	  //ENET1_TD1  -> (INTERRUP MX7D_PAD_ENET1_RGMII_TD1__GPIO7_IO7)
+		status = "okay"; 	//ENABLE_TOUCH -> GPIO1_IO04 (mosfet) (jumper permanente)
+	};
 };
 
 &i2c3 {
@@ -495,6 +555,50 @@
 	pinctrl-0 = <&pinctrl_i2c3>;
 	status = "okay";
 
+	tps6518x: tps6518x@68 {
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_tps6518x>;
+		compatible = "ti,tps6518x";
+		reg = <0x68>;
+		status = "okay";
+		/*
+		* power sequencing for TPS65180/65181
+		*/		 
+		pwr_seq0 = <0xe1>; /* [Vddh-seq=3 | Vpos-seq=2 | Vee-seq=0 | Vneg-seq=1] */
+		pwr_seq1 = <0x30>; /* [Vneg-dly1=3 |Vee-dly0=0]  mSec */
+		pwr_seq2 = <0x33>; /* [Vddh-dly3=3 | Vpos-dly2=3] mSec */
+		/*
+		 * Default power sequencing for TPS65185/65186, support E-Ink panel
+		 */
+		upseq0 = <0xe4>;	/* VNEG_UP - VEE_UP - VPOS_UP - VDDH_UP */
+		upseq1 = <0x55>;	/* 6ms + 6ms + 6ms + 6ms */
+		dwnseq0 = <0x1e>;	/* VDDH_UP - VPOS_UP - VEE_UP - VNEG_UP  */
+		dwnseq1 = <0xe0>;	/* 48ms + 24ms + 6 ms + 3ms */
+				
+		gpio_pmic_pwrgood = <&gpio2 31 0>;	// 63 - las mismas variables se llaman desde el device driver
+		gpio_pmic_vcom_ctrl = <&gpio7 0 0>; //(6*32)+0=192	  	
+		gpio_pmic_wakeup = <&gpio7 13 0>; 	//(6*32)+13=205   	
+		gpio_pmic_intr = <&gpio7 12 0>;   	//(6*32)+12=204 
+		gpio_pmic_powerup = <&gpio7 14 0>; 	//(6*32)+14=206 	  
+
+		regulators {
+			DISPLAY_reg: DISPLAY {
+				regulator-name = "DISPLAY";
+			};
+
+			VCOM_reg: VCOM {
+				regulator-name = "VCOM";
+				/* 2's-compliment, -4325000 */
+				regulator-min-microvolt = <0xffbe0178>;
+				/* 2's-compliment, -500000 */
+				regulator-max-microvolt = <0xfff85ee0>;
+			};
+
+			V3P3_reg: V3P3 {
+				regulator-name = "V3P3";
+			};
+		}; 
+	};
 };
 
 &i2c4 {
@@ -518,15 +622,65 @@
 				MX7D_PAD_SD1_CD_B__GPIO5_IO0		0x59 /* CD */
 				MX7D_PAD_SD1_RESET_B__GPIO5_IO2		0x59 /* vmmc */
 				MX7D_PAD_EPDC_SDCE3__GPIO2_IO23         0x59
-				MX7D_PAD_EPDC_DATA14__GPIO2_IO14        0x59  /* CAN_STBY */
+				//MX7D_PAD_EPDC_DATA14__GPIO2_IO14        0x59  /* CAN_STBY */
 			>;
 		};
 
+                pinctrl_epdc0: epdcgrp0 {
+                        fsl,pins = <
+				MX7D_PAD_EPDC_DATA00__EPDC_DATA0  0x80000000 	//0x2 
+				MX7D_PAD_EPDC_DATA01__EPDC_DATA1  0x80000000
+				MX7D_PAD_EPDC_DATA02__EPDC_DATA2  0x80000000
+				MX7D_PAD_EPDC_DATA03__EPDC_DATA3  0x80000000
+				MX7D_PAD_EPDC_DATA04__EPDC_DATA4  0x80000000
+				MX7D_PAD_EPDC_DATA05__EPDC_DATA5  0x80000000
+				MX7D_PAD_EPDC_DATA06__EPDC_DATA6  0x80000000
+				MX7D_PAD_EPDC_DATA07__EPDC_DATA7  0x80000000
+				MX7D_PAD_EPDC_DATA08__EPDC_DATA8  0x80000000
+				MX7D_PAD_EPDC_DATA09__EPDC_DATA9  0x80000000
+				MX7D_PAD_EPDC_DATA10__EPDC_DATA10 0x80000000
+				MX7D_PAD_EPDC_DATA11__EPDC_DATA11 0x80000000
+				MX7D_PAD_EPDC_DATA12__EPDC_DATA12 0x80000000
+				MX7D_PAD_EPDC_DATA13__EPDC_DATA13 0x80000000
+				MX7D_PAD_EPDC_DATA14__EPDC_DATA14 0x80000000
+				MX7D_PAD_EPDC_DATA15__EPDC_DATA15 0x80000000
+				MX7D_PAD_EPDC_SDCLK__EPDC_SDCLK   0x80000000
+				MX7D_PAD_EPDC_SDLE__EPDC_SDLE     0x80000000
+				MX7D_PAD_EPDC_SDOE__EPDC_SDOE     0x80000000
+				//MX7D_PAD_EPDC_SDSHR__EPDC_SDSHR   0x80000000
+				MX7D_PAD_EPDC_SDCE0__EPDC_SDCE0   0x80000000
+				//MX7D_PAD_EPDC_SDCE1__EPDC_SDCE1   0x80000000
+				MX7D_PAD_EPDC_GDCLK__EPDC_GDCLK   0x80000000
+				MX7D_PAD_EPDC_GDOE__EPDC_GDOE     0x80000000
+				//MX7D_PAD_EPDC_GDRL__EPDC_GDRL     0x80000000
+				MX7D_PAD_EPDC_GDSP__EPDC_GDSP     0x80000000
+				MX7D_PAD_EPDC_BDR0__EPDC_BDR0     0x80000000
+				MX7D_PAD_EPDC_BDR1__EPDC_BDR1     0x80000000
+                        >;
+                };
+
+			/* interrup touch elan BombShellV2 */
+		pinctrl_epdc_elan_touch: epdc_elan_touch_grp {
+			fsl,pins = <
+				MX7D_PAD_ENET1_RGMII_TD1__GPIO7_IO7	0x80000000	
+			>;
+		};
+
+		pinctrl_tps6518x: tps6518xgrp-1 {
+			fsl,pins = <		
+				MX7D_PAD_ENET1_RX_CLK__GPIO7_IO13	0x80000000//--MX7D_PAD_EPDC_SDCE3__GPIO2_IO23 /* wakeup */
+				MX7D_PAD_ENET1_RGMII_RD0__GPIO7_IO0 0x80000000//--MX7D_PAD_I2C4_SCL__GPIO4_IO14  /* vcom_ctrl */
+				MX7D_PAD_ENET1_TX_CLK__GPIO7_IO12	0x80000000// MX7D_PAD_EPDC_SDCE2__GPIO2_IO22 /* pwr int */
+				MX7D_PAD_EPDC_PWR_STAT__GPIO2_IO31	0x80000000/* pwrgood */  //Ok Idem 
+				MX7D_PAD_ENET1_CRS__GPIO7_IO14		0x80000000//MX7D_PAD_EPDC_PWR_COM__GPIO2_IO30 /* pwr-up-v3p3 */
+			>;
+		};
+/*
 		pinctrl_rgb_connector: rgb_connector_grp {
 			fsl,pins = <
 				MX7D_PAD_SD2_CD_B__GPIO5_IO9          0x1f0b0
-				MX7D_PAD_EPDC_GDSP__GPIO2_IO27        0x1f0b0
-			>;
+				//MX7D_PAD_EPDC_GDSP__GPIO2_IO27        0x1f0b0
+ 			>;
 		};
 
                 pinctrl_lvds0: lvds0_intgrp {
@@ -535,7 +689,7 @@
                         >;
                 };
 
-
+*/
 		pinctrl_ov5647: ov5647grp-1 {
 			fsl,pins = <
 				MX7D_PAD_I2C4_SCL__GPIO4_IO14           0x39
@@ -543,42 +697,10 @@
 			>;
 		};
 
-                pinctrl_epdc0: epdcgrp0 {
-                        fsl,pins = <
-				MX7D_PAD_EPDC_DATA00__EPDC_DATA0  0x2
-				MX7D_PAD_EPDC_DATA01__EPDC_DATA1  0x2
-				MX7D_PAD_EPDC_DATA02__EPDC_DATA2  0x2
-				MX7D_PAD_EPDC_DATA03__EPDC_DATA3  0x2
-				MX7D_PAD_EPDC_DATA04__EPDC_DATA4  0x2
-				MX7D_PAD_EPDC_DATA05__EPDC_DATA5  0x2
-				MX7D_PAD_EPDC_DATA06__EPDC_DATA6  0x2
-				MX7D_PAD_EPDC_DATA07__EPDC_DATA7  0x2
-				MX7D_PAD_EPDC_DATA08__EPDC_DATA8  0x2
-				MX7D_PAD_EPDC_DATA09__EPDC_DATA9  0x2
-				MX7D_PAD_EPDC_DATA10__EPDC_DATA10 0x2
-				MX7D_PAD_EPDC_DATA11__EPDC_DATA11 0x2
-				MX7D_PAD_EPDC_DATA12__EPDC_DATA12 0x2
-				MX7D_PAD_EPDC_DATA13__EPDC_DATA13 0x2
-				MX7D_PAD_EPDC_DATA14__EPDC_DATA14 0x2
-				MX7D_PAD_EPDC_DATA15__EPDC_DATA15 0x2
-				MX7D_PAD_EPDC_SDCLK__EPDC_SDCLK   0x2
-				MX7D_PAD_EPDC_SDLE__EPDC_SDLE     0x2
-				MX7D_PAD_EPDC_SDOE__EPDC_SDOE     0x2
-				MX7D_PAD_EPDC_SDSHR__EPDC_SDSHR   0x2
-				MX7D_PAD_EPDC_SDCE0__EPDC_SDCE0   0x2
-				MX7D_PAD_EPDC_SDCE1__EPDC_SDCE1   0x2
-				MX7D_PAD_EPDC_GDCLK__EPDC_GDCLK   0x2
-				MX7D_PAD_EPDC_GDOE__EPDC_GDOE     0x2
-				MX7D_PAD_EPDC_GDRL__EPDC_GDRL     0x2
-				MX7D_PAD_EPDC_GDSP__EPDC_GDSP     0x2
-				MX7D_PAD_EPDC_BDR0__EPDC_BDR0     0x2
-				MX7D_PAD_EPDC_BDR1__EPDC_BDR1     0x2
-                        >;
-                };
-
+/*
 		pinctrl_enet1: enet1grp {
 			fsl,pins = <
-				MX7D_PAD_GPIO1_IO10__ENET1_MDIO		0x3
+				/*MX7D_PAD_GPIO1_IO10__ENET1_MDIO		0x3
 				MX7D_PAD_GPIO1_IO11__ENET1_MDC		0x3
 				MX7D_PAD_ENET1_RGMII_TXC__ENET1_RGMII_TXC	0x1
 				MX7D_PAD_ENET1_RGMII_TD0__ENET1_RGMII_TD0	0x1
@@ -596,7 +718,7 @@
 				MX7D_PAD_ENET1_RX_CLK__GPIO7_IO13               0x1
 			>;
 		};
-
+*/
 		pinctrl_ecspi3_cs: ecspi3_cs_grp {
 			fsl,pins = <
 				MX7D_PAD_SD2_CD_B__GPIO5_IO9	0x80000000
@@ -652,7 +774,7 @@
 				MX7D_PAD_SAI1_RX_SYNC__I2C4_SCL		0x4000007f
 			>;
 		};
-
+/*
 		pinctrl_lcdif_dat: lcdifdatgrp {
 			fsl,pins = <
 				MX7D_PAD_LCD_DATA00__LCD_DATA0	0x79
@@ -681,7 +803,7 @@
 				MX7D_PAD_LCD_DATA23__LCD_DATA23	0x79
 			>;
 		};
-
+/*
 		pinctrl_lcdif_ctrl: lcdifctrlgrp {
 			fsl,pins = <
 				MX7D_PAD_LCD_CLK__LCD_CLK	0x79
@@ -689,11 +811,11 @@
 				MX7D_PAD_LCD_VSYNC__LCD_VSYNC	0x79
 				MX7D_PAD_LCD_HSYNC__LCD_HSYNC	0x79
 				MX7D_PAD_LCD_RESET__LCD_RESET	0x79
-				MX7D_PAD_EPDC_GDCLK__GPIO2_IO24 0x79
-				MX7D_PAD_EPDC_GDOE__GPIO2_IO25  0x79
+				//MX7D_PAD_EPDC_GDCLK__GPIO2_IO24 0x79
+				//MX7D_PAD_EPDC_GDOE__GPIO2_IO25  0x79
 			>;
 		};
-
+*/
 		pinctrl_uart1: uart1grp {
 			fsl,pins = <
 				MX7D_PAD_UART1_TX_DATA__UART1_DCE_TX 0x56
@@ -836,7 +958,7 @@
 
                 pinctrl_sai1: sai1grp {
                         fsl,pins = <
-                                MX7D_PAD_SAI1_MCLK__SAI1_MCLK           0x1f
+                MX7D_PAD_SAI1_MCLK__SAI1_MCLK           0x1f
 				MX7D_PAD_SAI1_TX_BCLK__SAI1_TX_BCLK     0x1f
 				MX7D_PAD_SAI1_TX_SYNC__SAI1_TX_SYNC     0x1f
 				MX7D_PAD_SAI1_TX_DATA__SAI1_TX_DATA0    0x30
@@ -852,18 +974,18 @@
 				MX7D_PAD_GPIO1_IO13__GPIO1_IO13	0x59
 			>;
 		};
-
+/*
 		pinctrl_qspi1_1: qspi1grp_1 {
 			fsl,pins = <
-				MX7D_PAD_EPDC_DATA00__QSPI_A_DATA0 0x51
-				MX7D_PAD_EPDC_DATA01__QSPI_A_DATA1 0x51
-				MX7D_PAD_EPDC_DATA02__QSPI_A_DATA2 0x51
-				MX7D_PAD_EPDC_DATA03__QSPI_A_DATA3 0x51
-				MX7D_PAD_EPDC_DATA05__QSPI_A_SCLK 0x51
-				MX7D_PAD_EPDC_DATA06__QSPI_A_SS0_B 0x51
+			//	MX7D_PAD_EPDC_DATA00__QSPI_A_DATA0 0x51
+			//	MX7D_PAD_EPDC_DATA01__QSPI_A_DATA1 0x51
+			//	MX7D_PAD_EPDC_DATA02__QSPI_A_DATA2 0x51
+			//	MX7D_PAD_EPDC_DATA03__QSPI_A_DATA3 0x51
+			//	MX7D_PAD_EPDC_DATA05__QSPI_A_SCLK 0x51
+			//	MX7D_PAD_EPDC_DATA06__QSPI_A_SS0_B 0x51
 			>;
 		};
-
+*/
 	};
 };
 
@@ -875,7 +997,6 @@
 		pinctrl_hog_2: hoggrp-2 {
 			fsl,pins = <
 				MX7D_PAD_GPIO1_IO05__GPIO1_IO5	0x14
-				MX7D_PAD_EPDC_DATA14__GPIO2_IO14 0x59  /* CAN_STBY */
 				MX7D_PAD_GPIO1_IO00__WDOD1_WDOG_B 0x74
 			>;
 		};
@@ -894,13 +1015,13 @@
 
 	};
 };
-
+/*
 &lcdif {
 	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_lcdif_dat
-		     &pinctrl_lcdif_ctrl>;
+	//pinctrl-0 = <&pinctrl_lcdif_dat
+//		     &pinctrl_lcdif_ctrl>;
 	pinctrl-assert-gpios = <&gpio2 25 GPIO_ACTIVE_HIGH>;
-	display = <&display0>;
+	display = <&display0>; //<&epdc0>;
 	status = "okay";
 
 	display0: display {
@@ -911,7 +1032,7 @@
                         native-mode = <&t_lcd>;
                         t_lcd: t_lcd_default {
                                 /* values may be changed in bootscript */
-                                clock-frequency = <33500000>;
+ /*                               clock-frequency = <33500000>;
                                 hactive = <800>;
                                 vactive = <480>;
                                 hback-porch = <89>;
@@ -930,7 +1051,18 @@
                 };
 
 	};
-};
+/*
+	epdc0: epdc {
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_epdc0>;
+        V3P3-supply = <&V3P3_reg>;
+        VCOM-supply = <&VCOM_reg>;
+        DISPLAY-supply = <&DISPLAY_reg>;
+		//en-gpios = <&gpio_spi 5 0>;
+        status = "okay";//"disabled";
+	};
+*/
+//};
 
 &pcie {
 	pinctrl-names = "default";
@@ -942,13 +1074,13 @@
 &pwm1 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_pwm1>;
-	status = "okay";
+	status = "disabled";//"okay";
 };
 
 &pwm3 {
         pinctrl-names = "default";
         pinctrl-0 = <&pinctrl_pwm3>;
-        status = "okay";
+        status = "disabled";//"okay";
 };
 
 
@@ -960,7 +1092,7 @@
 			  <&clks IMX7D_SAI1_ROOT_CLK>;
 	assigned-clock-parents = <&clks IMX7D_PLL_AUDIO_POST_DIV>;
 	assigned-clock-rates = <0>, <11289600>;
-	status = "okay";
+	status = "disabled";//"okay";
 };
 
 
@@ -1046,8 +1178,8 @@
 
 &qspi1 {
         pinctrl-names = "default";
-        pinctrl-0 = <&pinctrl_qspi1_1>;
-        status = "okay";
+        //pinctrl-0 = <&pinctrl_qspi1_1>;
+        status = "disable";  //"okay";
         ddrsmp=<0>;
 
         flash0: n25q256a@0 {
@@ -1058,7 +1190,9 @@
                 /* take off one dummy cycle */
                 spi-nor,ddr-quad-read-dummy = <6>;
                 reg = <0>;
+				status = "disabled";
         };
+
 };
 
 
diff --git a/arch/arm/configs/imx_v7_defconfig b/arch/arm/configs/imx_v7_defconfig
index b6d7c51..6419f87 100644
--- a/arch/arm/configs/imx_v7_defconfig
+++ b/arch/arm/configs/imx_v7_defconfig
@@ -165,6 +165,7 @@ CONFIG_TOUCHSCREEN_IMX6UL_TSC=y
 CONFIG_TOUCHSCREEN_MC13783=y
 CONFIG_TOUCHSCREEN_TSC2007=y
 CONFIG_TOUCHSCREEN_STMPE=y
+CONFIG_TOUCHSCREEN_KTF2K=y
 CONFIG_INPUT_MISC=y
 CONFIG_INPUT_MMA8450=y
 CONFIG_INPUT_MPL3115=y
@@ -196,6 +197,7 @@ CONFIG_SABRESD_MAX8903=y
 CONFIG_POWER_RESET=y
 CONFIG_POWER_RESET_SYSCON_POWEROFF=y
 CONFIG_SENSORS_MAX17135=y
+CONFIG_SENSORS_TPS6518X=y
 CONFIG_SENSORS_MAG3110=y
 CONFIG_THERMAL=y
 CONFIG_CPU_THERMAL=y
@@ -207,6 +209,7 @@ CONFIG_MFD_DA9052_I2C=y
 CONFIG_MFD_MC13XXX_SPI=y
 CONFIG_MFD_MC13XXX_I2C=y
 CONFIG_MFD_MAX17135=y
+CONFIG_MFD_TPS6518X=y
 CONFIG_MFD_SI476X_CORE=y
 CONFIG_MFD_STMPE=y
 CONFIG_REGULATOR=y
@@ -215,6 +218,7 @@ CONFIG_REGULATOR_ANATOP=y
 CONFIG_REGULATOR_DA9052=y
 CONFIG_REGULATOR_GPIO=y
 CONFIG_REGULATOR_MAX17135=y
+CONFIG_REGULATOR_TPS6518X=y
 CONFIG_REGULATOR_MC13783=y
 CONFIG_REGULATOR_MC13892=y
 CONFIG_REGULATOR_PFUZE100=y
diff --git a/arch/arm/configs/mx7dea-ucom_defconfig b/arch/arm/configs/mx7dea-ucom_defconfig
new file mode 100644
index 0000000..3111a87
--- /dev/null
+++ b/arch/arm/configs/mx7dea-ucom_defconfig
@@ -0,0 +1,440 @@
+CONFIG_KERNEL_LZO=y
+CONFIG_SYSVIPC=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_CGROUPS=y
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_EXPERT=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_PERF_EVENTS=y
+# CONFIG_SLUB_DEBUG is not set
+# CONFIG_COMPAT_BRK is not set
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_ARCH_MXC=y
+CONFIG_SOC_IMX50=y
+CONFIG_SOC_IMX53=y
+CONFIG_SOC_IMX6Q=y
+CONFIG_SOC_IMX6SL=y
+CONFIG_SOC_IMX6SX=y
+CONFIG_SOC_IMX6UL=y
+CONFIG_SOC_IMX7D=y
+CONFIG_SOC_VF610=y
+# CONFIG_SWP_EMULATE is not set
+CONFIG_SMP=y
+CONFIG_HAVE_ARM_ARCH_TIMER=y
+CONFIG_VMSPLIT_2G=y
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+CONFIG_HIGHMEM=y
+CONFIG_CMA=y
+CONFIG_CMDLINE="noinitrd console=ttymxc0,115200"
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_ARM_IMX6Q_CPUFREQ=y
+CONFIG_ARM_IMX7D_CPUFREQ=y
+CONFIG_CPU_IDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_BINFMT_MISC=m
+CONFIG_PM_DEBUG=y
+CONFIG_PM_TEST_SUSPEND=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_IPV6=y
+CONFIG_VLAN_8021Q=y
+CONFIG_LLC2=y
+CONFIG_CAN=y
+CONFIG_CAN_FLEXCAN=y
+CONFIG_CAN_M_CAN=y
+CONFIG_BT=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=y
+CONFIG_BT_HCIBTUSB=y
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_BCSP=y
+CONFIG_BT_HCIUART_ATH3K=y
+CONFIG_BT_HCIBCM203X=y
+CONFIG_BT_ATH3K=y
+CONFIG_CFG80211=y
+CONFIG_MAC80211=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+CONFIG_DMA_CMA=y
+CONFIG_CMA_SIZE_MBYTES=0
+CONFIG_IMX_WEIM=y
+CONFIG_CONNECTOR=y
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_PHYSMAP_OF=y
+CONFIG_MTD_DATAFLASH=y
+CONFIG_MTD_M25P80=y
+CONFIG_MTD_SST25L=y
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_GPMI_NAND=y
+CONFIG_MTD_NAND_MXC=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_SPI_FSL_QUADSPI=y
+CONFIG_MTD_UBI=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=65536
+CONFIG_SENSORS_FXOS8700=y
+CONFIG_SENSORS_FXAS2100X=y
+CONFIG_EEPROM_AT24=y
+CONFIG_EEPROM_AT25=y
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+# CONFIG_SCSI_LOWLEVEL is not set
+CONFIG_ATA=y
+CONFIG_SATA_AHCI_PLATFORM=y
+CONFIG_AHCI_IMX=y
+CONFIG_PATA_IMX=y
+CONFIG_NETDEVICES=y
+# CONFIG_NET_VENDOR_BROADCOM is not set
+CONFIG_CS89x0=y
+CONFIG_CS89x0_PLATFORM=y
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+CONFIG_SMC91X=y
+CONFIG_SMC911X=y
+CONFIG_SMSC911X=y
+# CONFIG_NET_VENDOR_STMICRO is not set
+CONFIG_MICREL_PHY=y
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_RTL8150=m
+CONFIG_USB_RTL8152=m
+CONFIG_USB_USBNET=m
+CONFIG_USB_NET_CDC_EEM=m
+CONFIG_BCMDHD=y
+CONFIG_BCMDHD_SDIO=y
+CONFIG_BCMDHD_FW_PATH="/lib/firmware/bcm/ZP_BCM4339/fw_bcmdhd.bin"
+CONFIG_BCMDHD_NVRAM_PATH="/lib/firmware/bcm/ZP_BCM4339/bcmdhd.ZP.SDIO.cal"
+# CONFIG_RTL_CARDS is not set
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_EVBUG=m
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_KEYBOARD_IMX=y
+CONFIG_MOUSE_PS2=m
+CONFIG_MOUSE_PS2_ELANTECH=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ADS7846=y
+CONFIG_TOUCHSCREEN_EGALAX=y
+CONFIG_TOUCHSCREEN_ELAN_TS=y
+CONFIG_TOUCHSCREEN_MAX11801=y
+CONFIG_TOUCHSCREEN_IMX6UL_TSC=y
+CONFIG_TOUCHSCREEN_MC13783=y
+CONFIG_TOUCHSCREEN_TSC2007=y
+CONFIG_TOUCHSCREEN_STMPE=y
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_MMA8450=y
+CONFIG_INPUT_MPL3115=y
+CONFIG_SENSOR_FXLS8471=y
+CONFIG_INPUT_ISL29023=y
+CONFIG_SERIO_SERPORT=m
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_IMX=y
+CONFIG_SERIAL_IMX_CONSOLE=y
+CONFIG_SERIAL_FSL_LPUART=y
+CONFIG_SERIAL_FSL_LPUART_CONSOLE=y
+CONFIG_FSL_OTP=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_HELPER_AUTO is not set
+CONFIG_I2C_ALGOPCF=m
+CONFIG_I2C_ALGOPCA=m
+CONFIG_I2C_IMX=y
+CONFIG_SPI=y
+CONFIG_SPI_GPIO=y
+CONFIG_SPI_IMX=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_MAX732X=y
+CONFIG_GPIO_PCA953X=y
+CONFIG_GPIO_74X164=y
+CONFIG_POWER_SUPPLY=y
+CONFIG_SABRESD_MAX8903=y
+CONFIG_POWER_RESET=y
+CONFIG_POWER_RESET_SYSCON_POWEROFF=y
+CONFIG_SENSORS_MAX17135=y
+CONFIG_SENSORS_TPS6518X=y
+CONFIG_SENSORS_MAG3110=y
+CONFIG_THERMAL=y
+CONFIG_CPU_THERMAL=y
+CONFIG_IMX_THERMAL=y
+CONFIG_DEVICE_THERMAL=y
+CONFIG_WATCHDOG=y
+CONFIG_IMX2_WDT=y
+CONFIG_MFD_DA9052_I2C=y
+CONFIG_MFD_MC13XXX_SPI=y
+CONFIG_MFD_MC13XXX_I2C=y
+CONFIG_MFD_MAX17135=y
+CONFIG_MFD_TPS6518X=y
+CONFIG_MFD_SI476X_CORE=y
+CONFIG_MFD_STMPE=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_ANATOP=y
+CONFIG_REGULATOR_DA9052=y
+CONFIG_REGULATOR_GPIO=y
+CONFIG_REGULATOR_MAX17135=y
+CONFIG_REGULATOR_TPS6518X=y
+CONFIG_REGULATOR_MC13783=y
+CONFIG_REGULATOR_MC13892=y
+CONFIG_REGULATOR_PFUZE100=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_RADIO_SUPPORT=y
+CONFIG_MEDIA_RC_SUPPORT=y
+CONFIG_RC_DEVICES=y
+CONFIG_IR_GPIO_CIR=y
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_VIDEO_MXC_OUTPUT=y
+CONFIG_VIDEO_MXC_CAPTURE=m
+CONFIG_MXC_CAMERA_OV5640=m
+CONFIG_MXC_CAMERA_OV5642=m
+CONFIG_MXC_CAMERA_OV5640_MIPI=m
+CONFIG_MXC_TVIN_ADV7180=m
+CONFIG_MXC_IPU_DEVICE_QUEUE_SDC=m
+CONFIG_VIDEO_MXC_IPU_OUTPUT=y
+CONFIG_VIDEO_MXC_PXP_V4L2=y
+CONFIG_VIDEO_MXC_CSI_CAMERA=m
+CONFIG_MXC_VADC=m
+CONFIG_MXC_MIPI_CSI=m
+CONFIG_MXC_CAMERA_OV5647_MIPI=m
+CONFIG_SOC_CAMERA=y
+CONFIG_VIDEO_MX3=y
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+CONFIG_VIDEO_CODA=y
+CONFIG_RADIO_SI476X=y
+CONFIG_SOC_CAMERA_OV2640=y
+CONFIG_DRM=y
+CONFIG_DRM_VIVANTE=y
+CONFIG_FB=y
+CONFIG_FB_MXS=y
+CONFIG_FB_MXC_SYNC_PANEL=y
+CONFIG_FB_MXC_MIPI_DSI=y
+CONFIG_FB_MXC_MIPI_DSI_SAMSUNG=y
+CONFIG_FB_MXC_TRULY_WVGA_SYNC_PANEL=y
+CONFIG_FB_MXC_TRULY_PANEL_TFT3P5079E=y
+CONFIG_FB_MXC_TRULY_PANEL_TFT3P5581E=y
+CONFIG_FB_MXC_LDB=y
+CONFIG_FB_MXC_HDMI=y
+CONFIG_FB_MXS_SII902X=y
+CONFIG_FB_MXC_DCIC=m
+CONFIG_HANNSTAR_CABC=y
+CONFIG_FB_MXC_EINK_PANEL=y
+CONFIG_FB_MXC_EINK_V2_PANEL=y
+CONFIG_LCD_CLASS_DEVICE=y
+CONFIG_LCD_L4F00242T03=y
+CONFIG_LCD_PLATFORM=y
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+CONFIG_LOGO=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_USB_AUDIO=m
+CONFIG_SND_SOC=y
+CONFIG_SND_IMX_SOC=y
+CONFIG_SND_SOC_EUKREA_TLV320=y
+CONFIG_SND_SOC_IMX_WM8960=y
+CONFIG_SND_SOC_IMX_SII902X=y
+CONFIG_SND_SOC_IMX_WM8958=y
+CONFIG_SND_SOC_IMX_CS42888=y
+CONFIG_SND_SOC_IMX_WM8962=y
+CONFIG_SND_SOC_IMX_SGTL5000=y
+CONFIG_SND_SOC_IMX_MQS=y
+CONFIG_SND_SOC_IMX_SPDIF=y
+CONFIG_SND_SOC_IMX_MC13783=y
+CONFIG_SND_SOC_IMX_SI476X=y
+CONFIG_SND_SOC_IMX_HDMI=y
+CONFIG_USB=y
+CONFIG_USB_OTG_WHITELIST=y
+CONFIG_USB_OTG_FSM=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_MXC=y
+CONFIG_USB_HCD_TEST_MODE=y
+CONFIG_USB_ACM=m
+CONFIG_USB_STORAGE=y
+CONFIG_USB_CHIPIDEA=y
+CONFIG_USB_CHIPIDEA_UDC=y
+CONFIG_USB_CHIPIDEA_HOST=y
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_OPTION=m
+CONFIG_USB_EHSET_TEST_FIXTURE=y
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_USB_MXS_PHY=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_CONFIGFS=m
+CONFIG_USB_CONFIGFS_SERIAL=y
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_OBEX=y
+CONFIG_USB_CONFIGFS_NCM=y
+CONFIG_USB_CONFIGFS_ECM=y
+CONFIG_USB_CONFIGFS_ECM_SUBSET=y
+CONFIG_USB_CONFIGFS_RNDIS=y
+CONFIG_USB_CONFIGFS_EEM=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_F_LB_SS=y
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_ZERO=m
+CONFIG_USB_ETH=m
+CONFIG_USB_G_NCM=m
+CONFIG_USB_GADGETFS=m
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_USB_G_SERIAL=m
+CONFIG_MMC=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_ESDHC_IMX=y
+CONFIG_MXC_IPU=y
+CONFIG_MXC_IPU_V3_PRE=y
+CONFIG_MXC_GPU_VIV=y
+CONFIG_MXC_SIM=y
+CONFIG_MXC_MIPI_CSI2=y
+CONFIG_MXC_HDMI_CEC=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_ONESHOT=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_BACKLIGHT=y
+CONFIG_LEDS_TRIGGER_GPIO=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+CONFIG_RTC_DRV_MC13XXX=y
+CONFIG_RTC_DRV_MXC=y
+CONFIG_RTC_DRV_SNVS=y
+CONFIG_DMADEVICES=y
+CONFIG_MXC_PXP_V2=y
+CONFIG_MXC_PXP_V3=y
+CONFIG_IMX_SDMA=y
+CONFIG_MXS_DMA=y
+CONFIG_DMATEST=m
+CONFIG_STAGING=y
+CONFIG_STAGING_MEDIA=y
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_IIO=y
+CONFIG_IMX7D_ADC=y
+CONFIG_VF610_ADC=y
+CONFIG_PWM=y
+CONFIG_PWM_IMX=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_JFFS2_FS=y
+CONFIG_UBIFS_FS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_ROOT_NFS=y
+CONFIG_NLS_DEFAULT="cp437"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_UTF8=y
+CONFIG_DEBUG_FS=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_FTRACE is not set
+CONFIG_SECURITYFS=y
+CONFIG_CRYPTO_USER=y
+CONFIG_CRYPTO_TEST=m
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CTS=y
+CONFIG_CRYPTO_LRW=y
+CONFIG_CRYPTO_XTS=y
+CONFIG_CRYPTO_MD4=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_RMD128=y
+CONFIG_CRYPTO_RMD160=y
+CONFIG_CRYPTO_RMD256=y
+CONFIG_CRYPTO_RMD320=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_TGR192=y
+CONFIG_CRYPTO_WP512=y
+CONFIG_CRYPTO_BLOWFISH=y
+CONFIG_CRYPTO_CAMELLIA=y
+CONFIG_CRYPTO_DES=y
+CONFIG_CRYPTO_TWOFISH=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_DEV_FSL_CAAM=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM_TEST=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SECVIO=y
+CONFIG_CRC_CCITT=m
+CONFIG_CRC_T10DIF=y
+CONFIG_CRC7=m
+CONFIG_LIBCRC32C=m
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
diff --git a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
index 315f3b8..8ab4ea0 100644
--- a/drivers/hwmon/Kconfig
+++ b/drivers/hwmon/Kconfig
@@ -787,6 +787,15 @@ config SENSORS_MAX17135
 	  This driver can also be built as a module.  If so, the module
 	  will be called max17135_sensor.
 
+config SENSORS_TPS6518X
+        tristate "Texas Instruments TPS6518X EPD temperature sensor"
+        depends on I2C
+        help
+          If you say yes here you get support for TPS6518X  PMIC sensor.
+
+          This driver can also be built as a module.  If so, the module
+          will be called tps6518x_sensor.
+
 config SENSORS_MAX197
 	tristate "Maxim MAX197 and compatibles"
 	help
diff --git a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
index bc29069..17f765a 100644
--- a/drivers/hwmon/Makefile
+++ b/drivers/hwmon/Makefile
@@ -110,6 +110,7 @@ obj-$(CONFIG_SENSORS_MAX16065)	+= max16065.o
 obj-$(CONFIG_SENSORS_MAX1619)	+= max1619.o
 obj-$(CONFIG_SENSORS_MAX1668)	+= max1668.o
 obj-$(CONFIG_SENSORS_MAX17135)  += max17135-hwmon.o
+obj-$(CONFIG_SENSORS_TPS6518X)  += tps6518x-hwmon.o
 obj-$(CONFIG_SENSORS_MAX197)	+= max197.o
 obj-$(CONFIG_SENSORS_MAX6639)	+= max6639.o
 obj-$(CONFIG_SENSORS_MAX6642)	+= max6642.o
diff --git a/drivers/hwmon/tps6518x-hwmon.c b/drivers/hwmon/tps6518x-hwmon.c
new file mode 100644
index 0000000..5032f91
--- /dev/null
+++ b/drivers/hwmon/tps6518x-hwmon.c
@@ -0,0 +1,331 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+/*
+ * tps65185.c
+ *
+ * Based on the MAX1619 driver.
+ * Copyright (C) 2003-2004 Alexey Fisher <fishor@mail.ru>
+ *                         Jean Delvare <khali@linux-fr.org>
+ *
+ * The TPS65185 is a sensor chip made by Texass Instruments.
+ * It reports up to two temperatures (its own plus up to
+ * one external one).
+ */
+
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/sysfs.h>
+#include <linux/platform_device.h>
+#include <linux/mfd/tps6518x.h>
+
+/*
+ * Conversions
+ */
+static int temp_from_reg(int val)
+{
+	return val;
+}
+
+/*
+ * Functions declaration
+ */
+static int tps6518x_sensor_probe(struct platform_device *pdev);
+static int tps6518x_sensor_remove(struct platform_device *pdev);
+
+static const struct platform_device_id tps6518x_sns_id[] = {
+	{ "tps6518x-sns", 0},
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(platform, tps6518x_sns_id);
+
+/*
+ * Driver data (common to all clients)
+ */
+static struct platform_driver tps6518x_sensor_driver = {
+	.probe = tps6518x_sensor_probe,
+	.remove = tps6518x_sensor_remove,
+	.id_table = tps6518x_sns_id,
+	.driver = {
+		.name = "tps6518x_sensor",
+	},
+};
+
+
+/*
+ * Client data (each client gets its own)
+ */
+struct tps6518x_data {
+	struct device *hwmon_dev;
+};
+
+/*
+ * Sysfs stuff
+ */
+static ssize_t show_temp_input(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	unsigned int reg_val;
+	/*
+	 * begin Temperature conversion
+	 */
+	tps6518x_reg_read(REG_TPS6518x_REVID,&reg_val);
+	printk("tps6518x_ show_temp_imput() reg_ID=%d \n",reg_val);	
+	switch (reg_val & 0xff)
+	{
+	   case TPS65180_PASS1 :
+	   case TPS65180_PASS2 :
+	   case TPS65181_PASS1 :
+	   case TPS65181_PASS2 :
+		    reg_val = 0x80;
+		    tps6518x_reg_write(REG_TPS65180_TMST_CONFIG, reg_val);
+		    // wait for completion completed
+		    while ((0x20 & reg_val) == 0)
+		    {
+		        msleep(1);
+		        tps6518x_reg_read(REG_TPS65180_TMST_CONFIG, &reg_val);
+		    }
+//			printk("tps6518x_ Show_temp_imput Function CASE:TPS65181_ value=%d\n",reg_val);				
+	        break;
+	   case TPS65185_PASS0 :
+	   case TPS65186_PASS0 :
+	   case TPS65185_PASS1 :
+	   case TPS65186_PASS1 :
+	   case TPS65185_PASS2 :
+	   case TPS65186_PASS2 :
+		    reg_val = 0x80;
+		    tps6518x_reg_write(REG_TPS65185_TMST1, reg_val);
+		    // wait for completion completed
+		    while ((0x20 & reg_val) == 0)
+		    {
+		        msleep(1);
+		        tps6518x_reg_read(REG_TPS65185_TMST1, &reg_val);
+		    }
+//			printk("tps6518x_ Show_temp_imput Function CASE:TPS65185_ value=%d\n",reg_val);
+	        break;
+	   default:
+		break;	
+
+	}
+
+	tps6518x_reg_read(REG_TPS6518x_TMST_VAL, &reg_val);
+	return snprintf(buf, PAGE_SIZE, "%d\n", temp_from_reg(reg_val));
+}
+
+static ssize_t show_intr_regs(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	unsigned int reg_val;
+	unsigned int intr_reg_val;
+	/*
+	 * get the interrupt status register value
+	 */
+	tps6518x_reg_read(REG_TPS6518x_REVID,&reg_val);
+	printk("tps6518x_ show_intr_regs() reg_ID=%d \n",reg_val);	
+	switch (reg_val & 0xff)
+	{
+	   case TPS65180_PASS1 :
+	   case TPS65180_PASS2 :
+	   case TPS65181_PASS1 :
+	   case TPS65181_PASS2 :
+		    tps6518x_reg_read(REG_TPS65180_INT1, &intr_reg_val);
+		    tps6518x_reg_read(REG_TPS65180_INT2, &reg_val);
+		    intr_reg_val |= reg_val<<8;
+//			printk("tps6518x_ show_int_regs() CASE:TPS65181_PASS2  value_INT2=%d \n",intr_reg_val);			
+	        break;
+	   case TPS65185_PASS0 :
+	   case TPS65186_PASS0 :
+	   case TPS65185_PASS1 :
+	   case TPS65186_PASS1 :
+	   case TPS65185_PASS2 :
+	   case TPS65186_PASS2 :
+		    tps6518x_reg_read(REG_TPS65185_INT1, &intr_reg_val);
+		    tps6518x_reg_read(REG_TPS65185_INT2, &reg_val);
+		    intr_reg_val |= reg_val<<8;
+//			printk("tps6518x_ show_int_regs() CASE:TPS65186_PASS2  value_INT2=%d \n",intr_reg_val);
+	        break;
+	   default:
+		break;	
+
+	}
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", intr_reg_val);
+}
+
+static ssize_t show_vcom(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	unsigned int reg_val;
+	unsigned int vcom_reg_val;
+	/*
+	 * get the vcom registers
+	 */
+	tps6518x_reg_read(REG_TPS6518x_REVID,&reg_val);
+	printk("tps6518x_ show_vcom() reg_ID=%d \n",reg_val);
+	switch (reg_val & 0xff)
+	{
+	   case TPS65180_PASS1 :
+	   case TPS65180_PASS2 :
+	   case TPS65181_PASS1 :
+	   case TPS65181_PASS2 :
+		    tps6518x_reg_read(REG_TPS65180_VCOM_ADJUST, &vcom_reg_val);
+//			printk("tps6518x_ show_vcom() CASE:TPS65181_PASS2  value=%d \n",vcom_reg_val);
+	        break;
+	   case TPS65185_PASS0 :
+	   case TPS65186_PASS0 :
+	   case TPS65185_PASS1 :
+	   case TPS65186_PASS1 :
+	   case TPS65185_PASS2 :
+	   case TPS65186_PASS2 :
+		    tps6518x_reg_read(REG_TPS65185_VCOM1, &vcom_reg_val);
+		    tps6518x_reg_read(REG_TPS65185_VCOM2, &reg_val);
+		    vcom_reg_val |= reg_val<<8;
+//			printk("tps6518x_ show_vcom() CASE:TPS65186_PASS2  value=%d \n",vcom_reg_val);
+	        break;
+	   default:
+		break;	
+
+	}
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", vcom_reg_val);
+}
+
+static ssize_t set_vcom(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int reg_val;
+	long vcom_reg_val = simple_strtol(buf,NULL,10);
+	/*
+	 * get the interrupt status register value
+	 */
+	tps6518x_reg_read(REG_TPS6518x_REVID,&reg_val);
+	printk("tps6518x_ set_vcom() reg_ID=%d \n",reg_val);
+	switch (reg_val & 0xff)
+	{
+	   case TPS65180_PASS1 :
+	   case TPS65180_PASS2 :
+	   case TPS65181_PASS1 :
+	   case TPS65181_PASS2 :
+		    tps6518x_reg_write(REG_TPS65180_VCOM_ADJUST, vcom_reg_val&0xff);
+//			printk("tps6518x_ set_vcom() CASE:TPS65181_PASS2 set_value=%d \n",(vcom_reg_val&0xff));
+	        break;
+	   case TPS65185_PASS0 :
+	   case TPS65186_PASS0 :
+	   case TPS65185_PASS1 :
+	   case TPS65186_PASS1 :
+	   case TPS65185_PASS2 :
+	   case TPS65186_PASS2 :
+		    tps6518x_reg_write(REG_TPS65185_VCOM1, vcom_reg_val&0xff);
+		    tps6518x_reg_write(REG_TPS65185_VCOM2, (vcom_reg_val>>8)&0xff);
+//			printk("tps6518x_ set_vcom() CASE:TPS65186_PASS2 set_valueVCOM2=%d \n",((vcom_reg_val>>8)&0xff));	
+	        break;
+	   default:
+		break;	
+
+	}
+
+	return count;
+}
+
+
+static DEVICE_ATTR(temp_input, S_IRUGO, show_temp_input, NULL);
+static DEVICE_ATTR(intr_input, S_IRUGO, show_intr_regs, NULL);
+static DEVICE_ATTR(vcom_value, S_IWUSR | S_IRUGO, show_vcom, set_vcom);
+
+static struct attribute *tps6518x_attributes[] = {
+	&dev_attr_temp_input.attr,
+	&dev_attr_intr_input.attr,
+	&dev_attr_vcom_value.attr,
+	NULL
+};
+
+static const struct attribute_group tps6518x_group = {
+	.attrs = tps6518x_attributes,
+};
+
+/*
+* Real code
+ */
+static int tps6518x_sensor_probe(struct platform_device *pdev)
+{
+	struct tps6518x_data *data;
+	int err;
+    printk("tps6518x_sensor_probe starting\n");
+
+	data = kzalloc(sizeof(struct tps6518x_data), GFP_KERNEL);
+	if (!data) {
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	/* Register sysfs hooks */
+	err = sysfs_create_group(&pdev->dev.kobj, &tps6518x_group);
+	if (err)
+		goto exit_free;
+
+	data->hwmon_dev = hwmon_device_register(&pdev->dev);
+	if (IS_ERR(data->hwmon_dev)) {
+		err = PTR_ERR(data->hwmon_dev);
+		goto exit_remove_files;
+	}
+
+	platform_set_drvdata(pdev, data);
+
+    printk("tps6518x_sensor_probe success\n");
+	return 0;
+
+exit_remove_files:
+	sysfs_remove_group(&pdev->dev.kobj, &tps6518x_group);
+exit_free:
+	kfree(data);
+exit:
+	return err;
+}
+
+static int tps6518x_sensor_remove(struct platform_device *pdev)
+{
+	struct tps6518x_data *data = platform_get_drvdata(pdev);
+	printk("tps6518x_ sensor_remove() \n");
+	hwmon_device_unregister(data->hwmon_dev);
+	sysfs_remove_group(&pdev->dev.kobj, &tps6518x_group);
+
+	kfree(data);
+	return 0;
+}
+
+static int __init sensors_tps6518x_init(void)
+{
+	return platform_driver_register(&tps6518x_sensor_driver);
+}
+module_init(sensors_tps6518x_init);
+
+static void __exit sensors_tps6518x_exit(void)
+{
+	platform_driver_unregister(&tps6518x_sensor_driver);
+}
+module_exit(sensors_tps6518x_exit);
+
+MODULE_DESCRIPTION("TPS6518x sensor driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 81f98e1..113215f 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -307,6 +307,18 @@ config TOUCHSCREEN_ELAN_TS
 	  To compile this driver as a module, choose M here: the
 	  module will be called elan-touch.
 
+config TOUCHSCREEN_KTF2K
+	tristate "ELAN touchscreen input driver (Chipset ektf2232)"
+	depends on I2C
+	help
+	  Say Y here if you have an I2C ELAN touchscreen
+	  attached.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called elan-ktf2k.
+
 config TOUCHSCREEN_FUJITSU
 	tristate "Fujitsu serial touchscreen"
 	select SERIO
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index c0fe4be..775cf27 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -35,6 +35,7 @@ obj-$(CONFIG_TOUCHSCREEN_EETI)		+= eeti_ts.o
 obj-$(CONFIG_TOUCHSCREEN_ELAN)		+= elants_i2c.o
 obj-$(CONFIG_TOUCHSCREEN_ELO)		+= elo.o
 obj-$(CONFIG_TOUCHSCREEN_ELAN_TS)      += elan_ts.o
+obj-$(CONFIG_TOUCHSCREEN_KTF2K)		+= ektf2k_5B.o
 obj-$(CONFIG_TOUCHSCREEN_EGALAX)	+= egalax_ts.o
 obj-$(CONFIG_TOUCHSCREEN_FUJITSU)	+= fujitsu_ts.o
 obj-$(CONFIG_TOUCHSCREEN_GOODIX)	+= goodix.o
diff --git a/drivers/input/touchscreen/ektf2k_5B.c b/drivers/input/touchscreen/ektf2k_5B.c
new file mode 100644
index 0000000..f767463
--- /dev/null
+++ b/drivers/input/touchscreen/ektf2k_5B.c
@@ -0,0 +1,1478 @@
+/* drivers/input/touchscreen/ektf2k.c - ELAN EKTF2K verions of driver
+ *
+ * Copyright (C) 2011 Elan Microelectronics Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * 2011/12/06: The first release, version 0x0001
+ * 2012/2/15:  The second release, version 0x0002 for new bootcode
+ * 2012/5/8:   Release version 0x0003 for china market
+ *             Integrated 2 and 5 fingers driver code together and
+ *             auto-mapping resolution.
+ * 2012/12/1:	 Release version 0x0005: support up to 10 fingers but no buffer mode.
+ *             Please change following parameters
+ *                 1. For 5 fingers protocol, please enable ELAN_PROTOCOL.
+                      The packet size is 18 or 24 bytes.
+ *                 2. For 10 fingers, please enable both ELAN_PROTOCOL and ELAN_TEN_FINGERS.
+                      The packet size is 40 or 4+40+40+40 (Buffer mode) bytes.
+ *                 3. Please enable the ELAN_BUTTON configuraton to support button.
+ *
+ * 2016/12/28: Add support 1 fingers mode.								 
+ */
+
+/* The ELAN_PROTOCOL support normanl packet format */	
+#define ELAN_PROTOCOL		
+
+//#define ELAN_TEN_FINGERS   /* james check: Can not be use to auto-resolution mapping */
+//#define ELAN_BUFFER_MODE
+//#define ELAN_BUTTON   	/* inicialise EV_KEY */
+
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/earlysuspend.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/device.h>
+#include <linux/jiffies.h>
+#include <linux/miscdevice.h>
+
+// for linux 2.6.36.3
+#include <linux/cdev.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <asm/ioctl.h>
+#include <linux/ektf2k.h> 
+
+#ifdef ELAN_TEN_FINGERS
+#define PACKET_SIZE		44		/* support 10 fingers packet */
+#else
+//#define PACKET_SIZE		8 		/* support 2 fingers packet  */
+#define PACKET_SIZE		24			/* support 5 fingers packet  */
+#endif
+
+#define PWR_STATE_DEEP_SLEEP	0
+#define PWR_STATE_NORMAL		1
+#define PWR_STATE_MASK			BIT(3)
+
+#define CMD_S_PKT		0x52
+#define CMD_R_PKT		0x53
+#define CMD_W_PKT		0x54
+
+#define HELLO_PKT		0x55
+
+#define TWO_FINGERS_PKT		0x5A
+#define FIVE_FINGERS_PKT	0x5D
+#define MTK_FINGERS_PKT		0x6D
+#define TEN_FINGERS_PKT		0x62
+#define BUFFER_PKT		0x63
+
+#define RESET_PKT		0x77
+#define CALIB_PKT		0xA8
+
+// modify
+#define SYSTEM_RESET_PIN_SR 	10
+
+//Add these Define
+#define IAP_IN_DRIVER_MODE 	1
+#define IAP_PORTION            	0
+#define PAGERETRY  30
+#define IAPRESTART 5
+
+
+// For Firmware Update 
+#define ELAN_IOCTLID	0xD0
+#define IOCTL_I2C_SLAVE	_IOW(ELAN_IOCTLID,  1, int)
+#define IOCTL_MAJOR_FW_VER  _IOR(ELAN_IOCTLID, 2, int)
+#define IOCTL_MINOR_FW_VER  _IOR(ELAN_IOCTLID, 3, int)
+#define IOCTL_RESET  _IOR(ELAN_IOCTLID, 4, int)
+#define IOCTL_IAP_MODE_LOCK  _IOR(ELAN_IOCTLID, 5, int)
+#define IOCTL_CHECK_RECOVERY_MODE  _IOR(ELAN_IOCTLID, 6, int)
+#define IOCTL_FW_VER  _IOR(ELAN_IOCTLID, 7, int)
+#define IOCTL_X_RESOLUTION  _IOR(ELAN_IOCTLID, 8, int)
+#define IOCTL_Y_RESOLUTION  _IOR(ELAN_IOCTLID, 9, int)
+#define IOCTL_FW_ID  _IOR(ELAN_IOCTLID, 10, int)
+#define IOCTL_ROUGH_CALIBRATE  _IOR(ELAN_IOCTLID, 11, int)
+#define IOCTL_IAP_MODE_UNLOCK  _IOR(ELAN_IOCTLID, 12, int)
+#define IOCTL_I2C_INT  _IOR(ELAN_IOCTLID, 13, int)
+#define IOCTL_RESUME  _IOR(ELAN_IOCTLID, 14, int)
+#define IOCTL_POWER_LOCK  _IOR(ELAN_IOCTLID, 15, int)
+#define IOCTL_POWER_UNLOCK  _IOR(ELAN_IOCTLID, 16, int)
+#define IOCTL_FW_UPDATE  _IOR(ELAN_IOCTLID, 17, int)
+#define IOCTL_BC_VER  _IOR(ELAN_IOCTLID, 18, int)
+#define IOCTL_2WIREICE  _IOR(ELAN_IOCTLID, 19, int)
+
+#define CUSTOMER_IOCTLID	0xA0
+#define IOCTL_CIRCUIT_CHECK  _IOR(CUSTOMER_IOCTLID, 1, int)
+#define IOCTL_GET_UPDATE_PROGREE	_IOR(CUSTOMER_IOCTLID,  2, int)
+
+uint8_t RECOVERY=0x00;
+int FW_VERSION=0x00;
+int X_RESOLUTION=320;//1288; 	//320;	// 7" 1280
+int Y_RESOLUTION=480;//832;	//480;	// 7" 2112
+int FW_ID=0x00;
+int work_lock=0x00;
+int power_lock=0x00;
+int circuit_ver=0x01;
+/*++++i2c transfer start+++++++*/
+int file_fops_addr=0x15;
+/*++++i2c transfer end+++++++*/
+
+int button_state = 0;
+
+#if IAP_PORTION
+uint8_t ic_status=0x00;	//0:OK 1:master fail 2:slave fail
+int update_progree=0;
+uint8_t I2C_DATA[3] = {0x15, 0x20, 0x21};/*I2C devices address*/  
+int is_OldBootCode = 0; // 0:new 1:old
+
+
+/*The newest firmware, if update must be changed here*/
+static uint8_t file_fw_data[] = {
+#include "fw_data.i_carbon"
+};
+
+
+enum
+{
+	PageSize		= 132,
+	PageNum	        = 249,
+	ACK_Fail		= 0x00,
+	ACK_OK			= 0xAA,
+	ACK_REWRITE		= 0x55,
+};
+
+enum
+{
+	E_FD			= -1,
+};
+#endif
+struct elan_ktf2k_ts_data {
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	struct workqueue_struct *elan_wq;
+	struct work_struct work;
+	struct early_suspend early_suspend;
+	int intr_gpio;
+// Firmware Information
+	int fw_ver;
+	int fw_id;
+	int bc_ver;
+	int x_resolution;
+	int y_resolution;
+// For Firmare Update 
+	struct miscdevice firmware;
+};
+
+static struct elan_ktf2k_ts_data *private_ts;
+static int __fw_packet_handler(struct i2c_client *client);
+static int elan_ktf2k_ts_rough_calibrate(struct i2c_client *client);
+static int elan_ktf2k_ts_resume(struct i2c_client *client);
+
+#if IAP_PORTION
+int Update_FW_One(/*struct file *filp,*/ struct i2c_client *client, int recovery);
+static int __hello_packet_handler(struct i2c_client *client);
+#endif
+// For Firmware Update 
+int elan_iap_open(struct inode *inode, struct file *filp){ 
+	printk("[ELAN]into elan_iap_open\n");
+		if (private_ts == NULL)  printk("private_ts is NULL~~~");
+		
+	return 0;
+}
+
+int elan_iap_release(struct inode *inode, struct file *filp){    
+	return 0;
+}
+
+static ssize_t elan_iap_write(struct file *filp, const char *buff, size_t count, loff_t *offp){  
+    int ret;
+    char *tmp;
+    printk("[ELAN]into elan_iap_write\n");
+
+    /*++++i2c transfer start+++++++*/    	
+    struct i2c_adapter *adap = private_ts->client->adapter;    	
+    struct i2c_msg msg;
+    /*++++i2c transfer end+++++++*/	
+
+    if (count > 8192)
+        count = 8192;
+
+    tmp = kmalloc(count, GFP_KERNEL);
+    
+    if (tmp == NULL)
+        return -ENOMEM;
+
+    if (copy_from_user(tmp, buff, count)) {
+        return -EFAULT;
+    }
+
+/*++++i2c transfer start+++++++*/
+#if 1
+	//down(&worklock);
+	msg.addr = file_fops_addr;
+	msg.flags = 0x00;// 0x00
+	msg.len = count;
+	msg.buf = (char *)tmp;
+	//up(&worklock);
+	ret = i2c_transfer(adap, &msg, 1);
+#else
+	
+    ret = i2c_master_send(private_ts->client, tmp, count);
+#endif	
+/*++++i2c transfer end+++++++*/
+
+    //if (ret != count) printk("ELAN i2c_master_send fail, ret=%d \n", ret);
+    kfree(tmp);
+    //return ret;
+    return (ret == 1) ? count : ret;
+
+}
+
+ssize_t elan_iap_read(struct file *filp, char *buff, size_t count, loff_t *offp){    
+    char *tmp;
+    int ret;  
+    long rc;
+    printk("[ELAN]into elan_iap_read\n");
+   /*++++i2c transfer start+++++++*/
+    	struct i2c_adapter *adap = private_ts->client->adapter;
+    	struct i2c_msg msg;
+/*++++i2c transfer end+++++++*/
+    if (count > 8192)
+        count = 8192;
+
+    tmp = kmalloc(count, GFP_KERNEL);
+
+    if (tmp == NULL)
+        return -ENOMEM;
+/*++++i2c transfer start+++++++*/
+#if 1
+	//down(&worklock);
+	msg.addr = file_fops_addr;
+	//msg.flags |= I2C_M_RD;
+	msg.flags = 0x00;
+	msg.flags |= I2C_M_RD;
+	msg.len = count;
+	msg.buf = tmp;
+	//up(&worklock);
+	ret = i2c_transfer(adap, &msg, 1);
+#else
+    ret = i2c_master_recv(private_ts->client, tmp, count);
+#endif
+/*++++i2c transfer end+++++++*/
+    if (ret >= 0)
+        rc = copy_to_user(buff, tmp, count);
+    
+    kfree(tmp);
+
+    //return ret;
+    return (ret == 1) ? count : ret;
+	
+}
+
+static long elan_iap_ioctl(/*struct inode *inode,*/ struct file *filp,    unsigned int cmd, unsigned long arg){
+
+	int __user *ip = (int __user *)arg;
+	printk("[ELAN]into elan_iap_ioctl\n");
+	printk("cmd value %x\n",cmd);
+	
+	switch (cmd) {        
+		case IOCTL_I2C_SLAVE: 
+			//private_ts->client->addr = (int __user)arg;
+			file_fops_addr = 0x15;
+			break;   
+		case IOCTL_MAJOR_FW_VER:            
+			break;        
+		case IOCTL_MINOR_FW_VER:            
+			break;        
+		case IOCTL_RESET:
+// modify
+		        gpio_set_value(SYSTEM_RESET_PIN_SR, 0);
+		        msleep(20);
+		        gpio_set_value(SYSTEM_RESET_PIN_SR, 1);
+		        msleep(100);
+
+			break;
+		case IOCTL_IAP_MODE_LOCK:
+			if(work_lock==0)
+			{
+				work_lock=1;
+				disable_irq(private_ts->client->irq);
+				cancel_work_sync(&private_ts->work);
+			}
+			break;
+		case IOCTL_IAP_MODE_UNLOCK:
+			if(work_lock==1)
+			{			
+				work_lock=0;
+				enable_irq(private_ts->client->irq);
+			}
+			break;
+		case IOCTL_CHECK_RECOVERY_MODE:
+			return RECOVERY;
+			break;
+		case IOCTL_FW_VER:
+			__fw_packet_handler(private_ts->client);
+			return FW_VERSION;
+			break;
+		case IOCTL_X_RESOLUTION:
+			__fw_packet_handler(private_ts->client);
+			return X_RESOLUTION;
+			break;
+		case IOCTL_Y_RESOLUTION:
+			__fw_packet_handler(private_ts->client);
+			return Y_RESOLUTION;
+			break;
+		case IOCTL_FW_ID:
+			__fw_packet_handler(private_ts->client);
+			return FW_ID;
+			break;
+		case IOCTL_ROUGH_CALIBRATE:
+			return elan_ktf2k_ts_rough_calibrate(private_ts->client);
+		case IOCTL_I2C_INT:
+			put_user(gpio_get_value(private_ts->intr_gpio), ip);
+			break;	
+		case IOCTL_RESUME:
+			elan_ktf2k_ts_resume(private_ts->client);
+			break;	
+		case IOCTL_POWER_LOCK:
+			power_lock=1;
+			break;
+		case IOCTL_POWER_UNLOCK:
+			power_lock=0;
+			break;
+#if IAP_PORTION		
+		case IOCTL_GET_UPDATE_PROGREE:
+			update_progree=(int __user)arg;
+			break; 
+		case IOCTL_FW_UPDATE:
+			Update_FW_One(private_ts->client, 0);
+			break;
+		case IOCTL_2WIREICE:
+//			TWO_WIRE_ICE(private_ts->client);
+			break;		
+#endif
+		case IOCTL_CIRCUIT_CHECK:
+			return circuit_ver;
+			break;
+		default:      
+			printk("[elan] Un-known IOCTL Command %d\n", cmd);      
+			break;   
+	}       
+	return 0;
+}
+
+struct file_operations elan_touch_fops = {    
+        .open =         elan_iap_open,    
+        .write =        elan_iap_write,    
+        .read = 	elan_iap_read,    
+        .release =	elan_iap_release,    
+	.unlocked_ioctl=elan_iap_ioctl, 
+ };
+#if IAP_PORTION
+int EnterISPMode(struct i2c_client *client, uint8_t  *isp_cmd)
+{
+	char buff[4] = {0};
+	int len = 0;
+	
+	len = i2c_master_send(private_ts->client, isp_cmd,  sizeof(isp_cmd));
+	if (len != sizeof(buff)) {
+		printk("[ELAN] ERROR: EnterISPMode fail! len=%d\r\n", len);
+		return -1;
+	}
+	else
+		printk("[ELAN] IAPMode write data successfully! cmd = [%2x, %2x, %2x, %2x]\n", isp_cmd[0], isp_cmd[1], isp_cmd[2], isp_cmd[3]);
+	return 0;
+}
+
+int ExtractPage(struct file *filp, uint8_t * szPage, int byte)
+{
+	int len = 0;
+
+	len = filp->f_op->read(filp, szPage,byte, &filp->f_pos);
+	if (len != byte) 
+	{
+		printk("[ELAN] ExtractPage ERROR: read page error, read error. len=%d\r\n", len);
+		return -1;
+	}
+
+	return 0;
+}
+
+int WritePage(uint8_t * szPage, int byte)
+{
+	int len = 0;
+
+	len = i2c_master_send(private_ts->client, szPage,  byte);
+	if (len != byte) 
+	{
+		printk("[ELAN] ERROR: write page error, write error. len=%d\r\n", len);
+		return -1;
+	}
+
+	return 0;
+}
+
+int GetAckData(struct i2c_client *client)
+{
+	int len = 0;
+
+	char buff[2] = {0};
+	
+	len=i2c_master_recv(private_ts->client, buff, sizeof(buff));
+	if (len != sizeof(buff)) {
+		printk("[ELAN] ERROR: read data error, write 50 times error. len=%d\r\n", len);
+		return -1;
+	}
+
+	pr_info("[ELAN] GetAckData:%x,%x",buff[0],buff[1]);
+	if (buff[0] == 0xaa/* && buff[1] == 0xaa*/) 
+		return ACK_OK;
+	else if (buff[0] == 0x55 && buff[1] == 0x55)
+		return ACK_REWRITE;
+	else
+		return ACK_Fail;
+
+	return 0;
+}
+
+void print_progress(int page, int ic_num, int j)
+{
+	int i, percent,page_tatol,percent_tatol;
+	char str[256];
+	str[0] = '\0';
+	for (i=0; i<((page)/10); i++) {
+		str[i] = '#';
+		str[i+1] = '\0';
+	}
+	
+	page_tatol=page+249*(ic_num-j);
+	percent = ((100*page)/(249));
+	percent_tatol = ((100*page_tatol)/(249*ic_num));
+
+	if ((page) == (249))
+		percent = 100;
+
+	if ((page_tatol) == (249*ic_num))
+		percent_tatol = 100;		
+
+	printk("\rprogress %s| %d%%", str, percent);
+	
+	if (page == (249))
+		printk("\n");
+}
+/* 
+* Restet and (Send normal_command ?)
+* Get Hello Packet
+*/
+int IAPReset(struct i2c_client *client)
+{
+	int res;
+	//reset
+	gpio_set_value(SYSTEM_RESET_PIN_SR, 0);
+	msleep(20);
+	gpio_set_value(SYSTEM_RESET_PIN_SR, 1);
+	msleep(100);
+
+
+	printk("[ELAN] read Hello packet data!\n"); 	  
+	res= __hello_packet_handler(client);
+	return res;
+}
+
+
+int Update_FW_One(struct i2c_client *client, int recovery)
+{
+	int res = 0,ic_num = 1;
+	int iPage = 0, rewriteCnt = 0; //rewriteCnt for PAGE_REWRITE
+	int i = 0;
+	uint8_t data;
+	//struct timeval tv1, tv2;
+	int restartCnt = 0; // For IAP_RESTART
+	
+	uint8_t recovery_buffer[4] = {0};
+	int byte_count;
+	uint8_t *szBuff = NULL;
+	int curIndex = 0;
+	uint8_t isp_cmd[] = {0x54, 0x00, 0x12, 0x34}; //{0x45, 0x49, 0x41, 0x50};
+
+	dev_dbg(&client->dev, "[ELAN] %s:  ic_num=%d\n", __func__, ic_num);
+IAP_RESTART:	
+	//reset
+// modify    
+
+
+	data=I2C_DATA[0];//Master
+	dev_dbg(&client->dev, "[ELAN] %s: address data=0x%x \r\n", __func__, data);
+
+	if(recovery != 0x80)
+	{
+        printk("[ELAN] Firmware upgrade normal mode !\n");
+		gpio_set_value(SYSTEM_RESET_PIN_SR,0);
+		mdelay(20);
+		gpio_set_value(SYSTEM_RESET_PIN_SR,1);
+		mdelay(150);
+		res = EnterISPMode(private_ts->client, isp_cmd);	 //enter ISP mode
+	} else
+        printk("[ELAN] Firmware upgrade recovery mode !\n");
+	//res = i2c_master_recv(private_ts->client, recovery_buffer, 4);   //55 aa 33 cc 
+	//printk("[ELAN] recovery byte data:%x,%x,%x,%x \n",recovery_buffer[0],recovery_buffer[1],recovery_buffer[2],recovery_buffer[3]);		
+
+	// Send Dummy Byte	
+	printk("[ELAN] send one byte data:%x,%x",private_ts->client->addr,data);
+	res = i2c_master_send(private_ts->client, &data,  sizeof(data));
+	if(res!=sizeof(data))
+	{
+		printk("[ELAN] dummy error code = %d\n",res);
+	}	
+	mdelay(10);
+
+
+	// Start IAP
+	for( iPage = 1; iPage <= PageNum; iPage++ ) 
+	{
+PAGE_REWRITE:
+#if 1 // 8byte mode
+		// 8 bytes
+		//szBuff = fw_data + ((iPage-1) * PageSize); 
+		for(byte_count=1;byte_count<=17;byte_count++)
+		{
+			if(byte_count!=17)
+			{		
+	//			printk("[ELAN] byte %d\n",byte_count);	
+	//			printk("curIndex =%d\n",curIndex);
+				szBuff = file_fw_data + curIndex;
+				curIndex =  curIndex + 8;
+
+				//ioctl(fd, IOCTL_IAP_MODE_LOCK, data);
+				res = WritePage(szBuff, 8);
+			}
+			else
+			{
+	//			printk("byte %d\n",byte_count);
+	//			printk("curIndex =%d\n",curIndex);
+				szBuff = file_fw_data + curIndex;
+				curIndex =  curIndex + 4;
+				//ioctl(fd, IOCTL_IAP_MODE_LOCK, data);
+				res = WritePage(szBuff, 4); 
+			}
+		} // end of for(byte_count=1;byte_count<=17;byte_count++)
+#endif 
+#if 0 // 132byte mode		
+		szBuff = file_fw_data + curIndex;
+		curIndex =  curIndex + PageSize;
+		res = WritePage(szBuff, PageSize);
+#endif
+//#if 0
+		if(iPage==249 || iPage==1)
+		{
+			mdelay(600); 			 
+		}
+		else
+		{
+			mdelay(50); 			 
+		}	
+		res = GetAckData(private_ts->client);
+
+		if (ACK_OK != res) 
+		{
+			mdelay(50); 
+			printk("[ELAN] ERROR: GetAckData fail! res=%d\r\n", res);
+			if ( res == ACK_REWRITE ) 
+			{
+				rewriteCnt = rewriteCnt + 1;
+				if (rewriteCnt == PAGERETRY)
+				{
+					printk("[ELAN] ID 0x%02x %dth page ReWrite %d times fails!\n", data, iPage, PAGERETRY);
+					return E_FD;
+				}
+				else
+				{
+					printk("[ELAN] ---%d--- page ReWrite %d times!\n",  iPage, rewriteCnt);
+					goto PAGE_REWRITE;
+				}
+			}
+			else
+			{
+				restartCnt = restartCnt + 1;
+				if (restartCnt >= 5)
+				{
+					printk("[ELAN] ID 0x%02x ReStart %d times fails!\n", data, IAPRESTART);
+					return E_FD;
+				}
+				else
+				{
+					printk("[ELAN] ===%d=== page ReStart %d times!\n",  iPage, restartCnt);
+					goto IAP_RESTART;
+				}
+			}
+		}
+		else
+		{       printk("  data : 0x%02x ",  data);  
+			rewriteCnt=0;
+			print_progress(iPage,ic_num,i);
+		}
+
+		mdelay(10);
+	} // end of for(iPage = 1; iPage <= PageNum; iPage++)
+
+	if (IAPReset(client) > 0)
+		printk("[ELAN] Update ALL Firmware successfully!\n");
+}
+
+#endif
+// End Firmware Update
+
+// Start sysfs
+static ssize_t elan_ktf2k_gpio_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int ret = 0;
+	struct elan_ktf2k_ts_data *ts = private_ts;
+
+	ret = gpio_get_value(ts->intr_gpio);
+	printk(KERN_DEBUG "GPIO_TP_INT_N=%d\n", ts->intr_gpio);
+	sprintf(buf, "GPIO_TP_INT_N=%d\n", ret);
+	ret = strlen(buf) + 1;
+	return ret;
+}
+
+static DEVICE_ATTR(gpio, S_IRUGO, elan_ktf2k_gpio_show, NULL);
+
+static ssize_t elan_ktf2k_vendor_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	ssize_t ret = 0;
+	struct elan_ktf2k_ts_data *ts = private_ts;
+
+	sprintf(buf, "%s_x%4.4x\n", "ELAN_KTF2K", ts->fw_ver);
+	ret = strlen(buf) + 1;
+	return ret;
+}
+
+static DEVICE_ATTR(vendor, S_IRUGO, elan_ktf2k_vendor_show, NULL);
+
+static struct kobject *android_touch_kobj;
+
+static int elan_ktf2k_touch_sysfs_init(void)
+{
+	int ret ;
+
+	android_touch_kobj = kobject_create_and_add("android_touch", NULL) ;
+	if (android_touch_kobj == NULL) {
+		printk(KERN_ERR "[elan]%s: subsystem_register failed\n", __func__);
+		ret = -ENOMEM;
+		return ret;
+	}
+	ret = sysfs_create_file(android_touch_kobj, &dev_attr_gpio.attr);
+	if (ret) {
+		printk(KERN_ERR "[elan]%s: sysfs_create_file failed\n", __func__);
+		return ret;
+	}
+	ret = sysfs_create_file(android_touch_kobj, &dev_attr_vendor.attr);
+	if (ret) {
+		printk(KERN_ERR "[elan]%s: sysfs_create_group failed\n", __func__);
+		return ret;
+	}
+	return 0 ;
+}
+
+static void elan_touch_sysfs_deinit(void)
+{
+	sysfs_remove_file(android_touch_kobj, &dev_attr_vendor.attr);
+	sysfs_remove_file(android_touch_kobj, &dev_attr_gpio.attr);
+	kobject_del(android_touch_kobj);
+}	
+
+// end sysfs
+
+static int __elan_ktf2k_ts_poll(struct i2c_client *client)
+{
+	struct elan_ktf2k_ts_data *ts = i2c_get_clientdata(client);
+	int status = 0, retry = 10;
+
+	do {
+		status = gpio_get_value(ts->intr_gpio);
+		printk("%s: status = %d\n", __func__, status);
+		retry--;
+		mdelay(50);
+	} while (status == 1 && retry > 0);
+
+	printk( "[elan]%s: poll interrupt status %s\n",
+			__func__, status == 1 ? "high" : "low");
+	return (status == 0 ? 0 : -ETIMEDOUT);
+}
+
+static int elan_ktf2k_ts_poll(struct i2c_client *client)
+{
+	return __elan_ktf2k_ts_poll(client);
+}
+
+static int elan_ktf2k_ts_get_data(struct i2c_client *client, uint8_t *cmd,
+			uint8_t *buf, size_t size)
+{
+	int rc;
+
+	dev_dbg(&client->dev, "[elan]%s: enter\n", __func__);
+
+	if (buf == NULL)
+		return -EINVAL;
+
+	if ((i2c_master_send(client, cmd, 4)) != 4) {
+		dev_err(&client->dev,
+			"[elan]%s: i2c_master_send failed\n", __func__);
+		return -EINVAL;
+	}
+
+	rc = elan_ktf2k_ts_poll(client);
+	if (rc < 0)
+		return -EINVAL;
+	else {
+		if (i2c_master_recv(client, buf, size) != size ||
+		    buf[0] != CMD_S_PKT)
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int __hello_packet_handler(struct i2c_client *client)
+{
+	int rc;
+	uint8_t buf_recv[8] = { 0 };
+
+	rc = elan_ktf2k_ts_poll(client);
+	if (rc < 0) {
+		printk( "[elan] %s: Int poll failed!\n", __func__);
+		RECOVERY=0x80;
+		return RECOVERY;
+		//return -EINVAL;
+	}
+
+	rc = i2c_master_recv(client, buf_recv, 8);
+	printk("[elan] %s: hello packet %2x:%2X:%2x:%2x:%2x:%2X:%2x:%2x\n", __func__, buf_recv[0], buf_recv[1], buf_recv[2], buf_recv[3] , buf_recv[4], buf_recv[5], buf_recv[6], buf_recv[7]);
+
+	if(buf_recv[0]==0x55 && buf_recv[1]==0x55 && buf_recv[2]==0x80 && buf_recv[3]==0x80)
+	{
+             RECOVERY=0x80;
+	     return RECOVERY; 
+	}
+	return 0;
+}
+
+static int __fw_packet_handler(struct i2c_client *client)
+{
+	struct elan_ktf2k_ts_data *ts = i2c_get_clientdata(client);
+	int rc;
+	int major, minor;
+	uint8_t cmd[] = {CMD_R_PKT, 0x00, 0x00, 0x01};/* Get Firmware Version*/
+	uint8_t cmd_x[] = {0x53, 0x60, 0x00, 0x00}; /*Get x resolution*/
+	uint8_t cmd_y[] = {0x53, 0x63, 0x00, 0x00}; /*Get y resolution*/
+	uint8_t cmd_id[] = {0x53, 0xf0, 0x00, 0x01}; /*Get firmware ID*/
+    uint8_t cmd_bc[] = {CMD_R_PKT, 0x01, 0x00, 0x01};/* Get BootCode Version*/
+	uint8_t buf_recv[4] = {0};
+// Firmware version
+	rc = elan_ktf2k_ts_get_data(client, cmd, buf_recv, 4);
+	if (rc < 0)
+		return rc;
+	major = ((buf_recv[1] & 0x0f) << 4) | ((buf_recv[2] & 0xf0) >> 4);
+	minor = ((buf_recv[2] & 0x0f) << 4) | ((buf_recv[3] & 0xf0) >> 4);
+	ts->fw_ver = major << 8 | minor;
+	FW_VERSION = ts->fw_ver;
+// Firmware ID
+	rc = elan_ktf2k_ts_get_data(client, cmd_id, buf_recv, 4);
+	if (rc < 0)
+		return rc;
+	major = ((buf_recv[1] & 0x0f) << 4) | ((buf_recv[2] & 0xf0) >> 4);
+	minor = ((buf_recv[2] & 0x0f) << 4) | ((buf_recv[3] & 0xf0) >> 4);
+	ts->fw_id = major << 8 | minor;
+	FW_ID = ts->fw_id;
+// Bootcode version
+        rc = elan_ktf2k_ts_get_data(client, cmd_bc, buf_recv, 4);
+        if (rc < 0)
+                return rc;
+        major = ((buf_recv[1] & 0x0f) << 4) | ((buf_recv[2] & 0xf0) >> 4);
+        minor = ((buf_recv[2] & 0x0f) << 4) | ((buf_recv[3] & 0xf0) >> 4);
+        ts->bc_ver = major << 8 | minor;
+
+// X Resolution
+	rc = elan_ktf2k_ts_get_data(client, cmd_x, buf_recv, 4);
+	if (rc < 0)
+		return rc;
+	minor = ((buf_recv[2])) | ((buf_recv[3] & 0xf0) << 4);
+	ts->x_resolution =minor;
+//#ifndef ELAN_TEN_FINGERS
+	X_RESOLUTION = ts->x_resolution;
+//#endif
+	
+// Y Resolution	
+	rc = elan_ktf2k_ts_get_data(client, cmd_y, buf_recv, 4);
+	if (rc < 0)
+		return rc;
+	minor = ((buf_recv[2])) | ((buf_recv[3] & 0xf0) << 4);
+	ts->y_resolution =minor;
+//#ifndef ELAN_TEN_FINGERS
+	Y_RESOLUTION = ts->y_resolution;
+//#endif
+	
+	printk(KERN_INFO "[elan] %s: Firmware version: 0x%4.4x\n",
+			__func__, ts->fw_ver);
+	printk(KERN_INFO "[elan] %s: Firmware ID: 0x%4.4x\n",
+			__func__, ts->fw_id);
+	printk(KERN_INFO "[elan] %s: Bootcode Version: 0x%4.4x\n",
+			__func__, ts->bc_ver);
+	printk(KERN_INFO "[elan] %s: x resolution: %d, y resolution: %d\n",
+			__func__, X_RESOLUTION, Y_RESOLUTION);
+	
+	return 0;
+}
+
+static inline int elan_ktf2k_ts_parse_xy(uint8_t *data,
+			uint16_t *x, uint16_t *y)
+{
+	*x = *y = 0;
+
+	*x = (data[0] & 0xf0);
+	*x <<= 4;
+	*x |= data[1];
+
+	*y = (data[0] & 0x0f);
+	*y <<= 8;
+	*y |= data[2];
+
+	return 0;
+}
+
+static int elan_ktf2k_ts_setup(struct i2c_client *client)
+{
+	int rc;
+	
+	rc = __hello_packet_handler(client);
+	printk("[elan] hellopacket's rc = %d\n",rc);
+
+	mdelay(10);
+	if (rc != 0x80){
+	    rc = __fw_packet_handler(client);
+	    if (rc < 0)
+		    printk("[elan] %s, fw_packet_handler fail, rc = %d", __func__, rc);
+	    dev_dbg(&client->dev, "[elan] %s: firmware checking done.\n", __func__);
+//Check for FW_VERSION, if 0x0000 means FW update fail!
+	    if ( FW_VERSION == 0x00)
+	    {
+		rc = 0x80;
+		printk("[elan] FW_VERSION = %d, last FW update fail\n", FW_VERSION);
+	    }
+      }
+	return rc;
+}
+
+static int elan_ktf2k_ts_rough_calibrate(struct i2c_client *client){
+      uint8_t cmd[] = {CMD_W_PKT, 0x29, 0x00, 0x01};
+
+	//dev_info(&client->dev, "[elan] %s: enter\n", __func__);
+	printk("[elan] %s: enter\n", __func__);
+	dev_info(&client->dev,
+		"[elan] dump cmd: %02x, %02x, %02x, %02x\n",
+		cmd[0], cmd[1], cmd[2], cmd[3]);
+
+	if ((i2c_master_send(client, cmd, sizeof(cmd))) != sizeof(cmd)) {
+		dev_err(&client->dev,
+			"[elan] %s: i2c_master_send failed\n", __func__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int elan_ktf2k_ts_set_power_state(struct i2c_client *client, int state)
+{
+	uint8_t cmd[] = {CMD_W_PKT, 0x50, 0x00, 0x01};
+
+	dev_dbg(&client->dev, "[elan] %s: enter\n", __func__);
+
+	cmd[1] |= (state << 3);
+
+	dev_dbg(&client->dev,
+		"[elan] dump cmd: %02x, %02x, %02x, %02x\n",
+		cmd[0], cmd[1], cmd[2], cmd[3]);
+
+	if ((i2c_master_send(client, cmd, sizeof(cmd))) != sizeof(cmd)) {
+		dev_err(&client->dev,
+			"[elan] %s: i2c_master_send failed\n", __func__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int elan_ktf2k_ts_get_power_state(struct i2c_client *client)
+{
+	int rc = 0;
+	uint8_t cmd[] = {CMD_R_PKT, 0x50, 0x00, 0x01};
+	uint8_t buf[4], power_state;
+
+	rc = elan_ktf2k_ts_get_data(client, cmd, buf, 4);
+	if (rc)
+		return rc;
+
+	power_state = buf[1];
+	dev_dbg(&client->dev, "[elan] dump repsponse: %0x\n", power_state);
+	power_state = (power_state & PWR_STATE_MASK) >> 3;
+	dev_dbg(&client->dev, "[elan] power state = %s\n",
+		power_state == PWR_STATE_DEEP_SLEEP ?
+		"Deep Sleep" : "Normal/Idle");
+
+	return power_state;
+}
+
+static int elan_ktf2k_ts_recv_data(struct i2c_client *client, uint8_t *buf, int bytes_to_recv)
+{
+
+	int rc;
+	if (buf == NULL)
+		return -EINVAL;
+
+	memset(buf, 0, bytes_to_recv);
+
+/* The ELAN_PROTOCOL support normanl packet format */	
+#ifdef ELAN_PROTOCOL		
+	rc = i2c_master_recv(client, buf, bytes_to_recv);
+//printk("[elan] Elan protocol rc = %d \n", rc);     //cometo debug
+	if (rc != bytes_to_recv) {
+		dev_err(&client->dev, "[elan] %s: i2c_master_recv error?! \n", __func__);
+		return -1;
+	}
+
+#else 
+	rc = i2c_master_recv(client, buf, 8);
+	if (rc != 8)
+	{
+		 printk("[elan] Read the first package error.\n");
+		 mdelay(30);
+		 return -1;
+  }
+  printk("[elan_debug] %x %x %x %x %x %x %x %x\n", buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7]);
+	mdelay(1);
+	
+  if (buf[0] == 0x6D){    //for five finger
+	  rc = i2c_master_recv(client, buf+ 8, 8);	
+	  if (rc != 8)
+	  {
+		      printk("[elan] Read the second package error.\n");
+		      mdelay(30);
+		      return -1;
+		}		      
+    printk("[elan_debug] %x %x %x %x %x %x %x %x\n", buf[8], buf[9], buf[10], buf[11], buf[12], buf[13], buf[14], buf[15]);
+	  rc = i2c_master_recv(client, buf+ 16, 2);
+    if (rc != 2)
+    {
+		      printk("[elan] Read the third package error.\n");
+		      mdelay(30);
+		      return -1;
+		}		      
+	  mdelay(1);
+    printk("[elan_debug] %x %x \n", buf[16], buf[17]);
+  }
+#endif
+//comento debug
+//printk("[elan_debug] end ts_work\n");
+	return rc;
+}
+
+static void elan_ktf2k_ts_report_data(struct i2c_client *client, uint8_t *buf)
+{
+	struct elan_ktf2k_ts_data *ts = i2c_get_clientdata(client);
+	struct input_dev *idev = ts->input_dev;
+	uint16_t x, y;
+	uint16_t fbits=0;
+	uint8_t i, num, reported = 0;
+	uint8_t idx, btn_idx;
+	int finger_num;
+	
+/* for 10 fingers	*/
+	if (buf[0] == TEN_FINGERS_PKT){
+	    	finger_num = 10;
+	    	num = buf[2] & 0x0f; 
+	    	fbits = buf[2] & 0x30;	
+		fbits = (fbits << 4) | buf[1]; 
+	    	idx=3;
+		btn_idx=33;
+      }
+/* for 5 fingers	*/
+   		else if ((buf[0] == MTK_FINGERS_PKT) || (buf[0] == FIVE_FINGERS_PKT)){
+	    	finger_num = 5;
+	    	num = buf[1] & 0x07; 
+        fbits = buf[1] >>3;
+	    	idx=2;
+		btn_idx=17;
+      }else{
+/* for 2 fingers */    
+      	finger_num = 2;
+	    	num = buf[7] & 0x06;		// for elan old 5D protocol the finger ID is 0x06
+        fbits = (buf[7] & 0x06) >> 1;	// for elan old 5D protocol the finger ID is 0x06
+	    	idx=1;
+		btn_idx=7;
+			}
+		
+    switch (buf[0]) {
+    	case MTK_FINGERS_PKT:
+    	case TWO_FINGERS_PKT:
+    	case FIVE_FINGERS_PKT:	
+		case TEN_FINGERS_PKT:
+		input_report_key(idev, BTN_TOUCH, 1);
+			if (num == 0) {
+#ifdef ELAN_BUTTON
+				if (buf[btn_idx] == 0x21) 
+        {
+						button_state = 0x21;
+						input_report_key(idev, KEY_BACK, 1);
+						input_report_key(idev, KEY_BACK, 0);
+printk("[elan_debug] button %x \n", buf[btn_idx]);
+				} 
+				else if (buf[btn_idx] == 0x41)
+				{
+						button_state = 0x41;
+						input_report_key(idev, KEY_HOME, 1);
+				} 
+				else if (buf[btn_idx] == 0x81)
+				{
+						button_state = 0x81;
+						input_report_key(idev, KEY_MENU, 1);
+				} 
+				else if (button_state == 0x21) 
+				{
+						button_state=0;
+						input_report_key(idev, KEY_BACK, 0);
+		    } 
+				else if (button_state == 0x41) 
+				{
+						button_state=0;
+						input_report_key(idev, KEY_HOME, 0);
+				} 
+				else if (button_state == 0x81) 
+				{
+						button_state=0;
+						input_report_key(idev, KEY_MENU, 0);
+				}
+				else
+				{
+				dev_dbg(&client->dev, "no press\n");
+				input_mt_sync(idev);
+				}
+				
+#endif	
+			} else {			
+				dev_dbg(&client->dev, "[elan] %d fingers\n", num);                        
+				input_report_key(idev, BTN_TOUCH, 1);
+				for (i = 0; i < finger_num; i++) {	
+			  	if ((fbits & 0x01)) {
+			    	elan_ktf2k_ts_parse_xy(&buf[idx], &x, &y);  
+
+		      //elan_ktf2k_ts_parse_xy(&buf[idx], &y, &x);  		 
+		////	     	printk("[elan_debug] %s, x=%d, y=%d\n",__func__, x , y); //DEBUG message
+			    //x = X_RESOLUTION-x;	 
+			    //y = Y_RESOLUTION-y;			     
+						if (!((x<=0) || (y<=0) || (x>=X_RESOLUTION) || (y>=Y_RESOLUTION))) {   
+    					input_report_abs(idev, ABS_MT_TRACKING_ID, i);
+							input_report_abs(idev, ABS_MT_TOUCH_MAJOR, 8);
+							input_report_abs(idev, ABS_MT_POSITION_X, x);
+							input_report_abs(idev, ABS_MT_POSITION_Y, y);
+							input_mt_sync(idev);
+							reported++;
+			  		} // end if border
+					} // end if finger status
+			  	fbits = fbits >> 1;
+			  	idx += 3;
+				} // end for
+			}
+			if (reported)
+				input_sync(idev);
+			else {
+				input_mt_sync(idev);
+				input_sync(idev);
+			}
+			break;
+	   	default:
+				dev_err(&client->dev,
+								"[elan] %s: unknown packet type: %0x\n", __func__, buf[0]);
+				break;
+		} // end switch
+
+	return;
+}
+
+static void elan_ktf2k_ts_work_func(struct work_struct *work)
+{
+	int rc;
+	struct elan_ktf2k_ts_data *ts =
+	container_of(work, struct elan_ktf2k_ts_data, work);
+	uint8_t buf[PACKET_SIZE] = { 0 };
+	uint8_t buf1[40] = { 0 };
+	uint16_t x, y;
+
+		if (gpio_get_value(ts->intr_gpio))
+		{
+			printk("[elan] Detected the jitter on INT pin");
+			enable_irq(ts->client->irq);
+			return;
+		}
+	
+		rc = elan_ktf2k_ts_recv_data(ts->client, buf,PACKET_SIZE);
+ 
+		if (rc < 0)
+		{
+			printk("[elan] Received the packet Error.\n");
+			enable_irq(ts->client->irq);
+			return;
+		}
+		/******* Disparo eventos 1-Finger ***********/ //Corregir valores (x,y)
+		if(buf[7] == 0x01)
+		{
+				input_report_key(ts->input_dev, BTN_TOUCH , 1);
+				elan_ktf2k_ts_parse_xy(&buf[2], &x, &y);
+				input_report_abs(ts->input_dev, ABS_X , x);// ((int) buf[2] ));    //(int) ( (buf[2]&0xf0) << 4 | (buf[2]&0x0f) ) )); // x); //
+				input_report_abs(ts->input_dev, ABS_Y , y);//((int) buf[3] ));	//(int) ( (buf[3]&0xf0) << 4	| (buf[3]&0x0f) ) )); // y);					
+				//printk("[elan] ---> PRESS 01  \n");
+		}else if(buf[7] == 0x00)
+		{
+				input_report_key(ts->input_dev, BTN_TOUCH , 0);
+				//printk("[elan] ---> PRESS 00  \n");		
+		}
+//comento debug
+//		printk("[elan_debug] %2x,%2x,%2x,%2x,%2x,%2x,%2x,%2x ..YY..., %2x\n",buf[0],buf[1],buf[2],buf[3],buf[4],buf[5],buf[6],buf[7],buf[17]);
+
+#ifndef ELAN_BUFFER_MODE
+		elan_ktf2k_ts_report_data(ts->client, buf);
+#else
+		elan_ktf2k_ts_report_data(ts->client, buf+4);
+
+ 	// Second package
+	if ((buf[0] == 0x63) && ((buf[1] == 2) || (buf[1] == 3))) {
+		rc = elan_ktf2k_ts_recv_data(ts->client, buf1, 40);
+		if (rc < 0){
+			enable_irq(ts->client->irq);
+                                return;
+		}
+		elan_ktf2k_ts_report_data(ts->client, buf1);
+	// Final package
+		if (buf[1] == 3) {
+			rc = elan_ktf2k_ts_recv_data(ts->client, buf1, 40);
+			if (rc < 0){
+				enable_irq(ts->client->irq);
+				return;
+			}
+			elan_ktf2k_ts_report_data(ts->client, buf1);
+		}
+	}
+#endif
+
+		enable_irq(ts->client->irq);
+
+	return;
+}
+
+static irqreturn_t elan_ktf2k_ts_irq_handler(int irq, void *dev_id)
+{
+	struct elan_ktf2k_ts_data *ts = dev_id;
+	struct i2c_client *client = ts->client;
+
+	dev_dbg(&client->dev, "[elan] %s\n", __func__);
+	disable_irq_nosync(ts->client->irq);
+	queue_work(ts->elan_wq, &ts->work);
+
+	return IRQ_HANDLED;
+}
+
+static int elan_ktf2k_ts_register_interrupt(struct i2c_client *client)
+{
+	struct elan_ktf2k_ts_data *ts = i2c_get_clientdata(client);
+	int err = 0;
+
+	err = request_irq(client->irq, elan_ktf2k_ts_irq_handler,
+											IRQF_TRIGGER_LOW, client->name, ts);
+	if (err)
+		dev_err(&client->dev, "[elan] %s: request_irq %d failed\n",
+				__func__, client->irq);
+
+	return err;
+}
+
+static int elan_ktf2k_ts_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	int err = 0;
+	int fw_err = 0;
+	struct elan_ktf2k_i2c_platform_data *pdata;
+	struct elan_ktf2k_ts_data *ts;
+	int New_FW_ID;	
+	int New_FW_VER;	
+		
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		printk(KERN_ERR "[elan] %s: i2c check functionality error\n", __func__);
+		err = -ENODEV;
+		goto err_check_functionality_failed;
+	}
+
+	ts = kzalloc(sizeof(struct elan_ktf2k_ts_data), GFP_KERNEL);
+	if (ts == NULL) {
+		printk(KERN_ERR "[elan] %s: allocate elan_ktf2k_ts_data failed\n", __func__);
+		err = -ENOMEM;
+		goto err_alloc_data_failed;
+	}
+
+	ts->elan_wq = create_singlethread_workqueue("elan_wq");
+	if (!ts->elan_wq) {
+		printk(KERN_ERR "[elan] %s: create workqueue failed\n", __func__);
+		err = -ENOMEM;
+		goto err_create_wq_failed;
+	}
+
+	INIT_WORK(&ts->work, elan_ktf2k_ts_work_func);
+	ts->client = client;
+	i2c_set_clientdata(client, ts);
+// james: maybe remove	
+	pdata = client->dev.platform_data;
+	if (likely(pdata != NULL)) {
+		ts->intr_gpio = pdata->intr_gpio;
+	}
+
+	fw_err = elan_ktf2k_ts_setup(client);
+	if (fw_err < 0) {
+		printk(KERN_INFO "No Elan chip inside\n");
+//		fw_err = -ENODEV;  
+	}
+
+	ts->input_dev = input_allocate_device();
+	if (ts->input_dev == NULL) {
+		err = -ENOMEM;
+		dev_err(&client->dev, "[elan] Failed to allocate input device\n");
+		goto err_input_dev_alloc_failed;
+	}
+	ts->input_dev->name = "elan-touchscreen";   // for andorid2.2 Froyo  
+
+	set_bit(BTN_TOUCH, ts->input_dev->keybit);
+#ifdef ELAN_BUTTON
+	set_bit(KEY_BACK, ts->input_dev->keybit);
+	set_bit(KEY_MENU, ts->input_dev->keybit);
+	set_bit(KEY_HOME, ts->input_dev->keybit);
+	set_bit(KEY_SEARCH, ts->input_dev->keybit);
+#endif
+
+	input_set_abs_params(ts->input_dev, ABS_X, 0,  X_RESOLUTION, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_Y, 0,  Y_RESOLUTION, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_PRESSURE, 0, 255, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_TOOL_WIDTH, 0, 255, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0, X_RESOLUTION, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, Y_RESOLUTION, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_TRACKING_ID, 0, 5, 0, 0);	
+/*
+	__set_bit(EV_ABS, ts->input_dev->evbit);
+	__set_bit(EV_SYN, ts->input_dev->evbit);
+	__set_bit(EV_KEY, ts->input_dev->evbit);
+*/
+	set_bit(EV_ABS, ts->input_dev->evbit);
+	set_bit(EV_SYN, ts->input_dev->evbit);
+	set_bit(EV_KEY, ts->input_dev->evbit);
+
+	err = input_register_device(ts->input_dev);
+	if (err) {
+		dev_err(&client->dev,
+			"[elan]%s: unable to register %s input device\n",
+			__func__, ts->input_dev->name);
+		goto err_input_register_device_failed;
+	}
+
+	elan_ktf2k_ts_register_interrupt(ts->client);
+
+	if (gpio_get_value(ts->intr_gpio) == 0) {
+		printk(KERN_INFO "[elan]%s: handle missed interrupt\n", __func__);
+		elan_ktf2k_ts_irq_handler(client->irq, ts);
+	}
+
+	private_ts = ts;
+
+	elan_ktf2k_touch_sysfs_init();
+
+	dev_info(&client->dev, "[elan] Start touchscreen %s in interrupt mode\n",
+		ts->input_dev->name);
+
+// Firmware Update
+	ts->firmware.minor = MISC_DYNAMIC_MINOR;
+	ts->firmware.name = "elan-iap";
+	ts->firmware.fops = &elan_touch_fops;
+	ts->firmware.mode = S_IFREG|S_IRWXUGO; 
+
+	if (misc_register(&ts->firmware) < 0)
+  		printk("[ELAN]misc_register failed!!");
+  	else
+		printk("[ELAN]misc_register finished!!");
+// End Firmware Update	
+#if IAP_PORTION
+	if(1)
+	{
+    printk("[ELAN]misc_register finished!!");
+		work_lock=1;
+		disable_irq(ts->client->irq);
+		cancel_work_sync(&ts->work);
+	
+		power_lock = 1;
+/* FW ID & FW VER*/
+#if 0  /* For ektf21xx and ektf20xx  */
+    printk("[ELAN]  [7bd0]=0x%02x,  [7bd1]=0x%02x, [7bd2]=0x%02x, [7bd3]=0x%02x\n",  file_fw_data[31696],file_fw_data[31697],file_fw_data[31698],file_fw_data[31699]);
+		New_FW_ID = file_fw_data[31699]<<8  | file_fw_data[31698] ;	       
+		New_FW_VER = file_fw_data[31697]<<8  | file_fw_data[31696] ;
+#endif
+		
+#if 0   /* for ektf31xx 2 wire ice ex: 2wireice -b xx.bin */
+    printk(" [7c16]=0x%02x,  [7c17]=0x%02x, [7c18]=0x%02x, [7c19]=0x%02x\n",  file_fw_data[31766],file_fw_data[31767],file_fw_data[31768],file_fw_data[31769]);
+		New_FW_ID = file_fw_data[31769]<<8  | file_fw_data[31768] ;	       
+		New_FW_VER = file_fw_data[31767]<<8  | file_fw_data[31766] ;
+#endif	
+    /* for ektf31xx iap ekt file   */	
+    printk(" [7bd8]=0x%02x,  [7bd9]=0x%02x, [7bda]=0x%02x, [7bdb]=0x%02x\n",  file_fw_data[31704],file_fw_data[31705],file_fw_data[31706],file_fw_data[31707]);
+		New_FW_ID = file_fw_data[31707]<<8  | file_fw_data[31708] ;	       
+		New_FW_VER = file_fw_data[31705]<<8  | file_fw_data[31704] ;
+	  printk(" FW_ID=0x%x,   New_FW_ID=0x%x \n",  FW_ID, New_FW_ID);   	       
+		printk(" FW_VERSION=0x%x,   New_FW_VER=0x%x \n",  FW_VERSION  , New_FW_VER);  
+
+/* for firmware auto-upgrade            
+	  if (New_FW_ID   ==  FW_ID){		      
+		   	if (New_FW_VER > (FW_VERSION)) 
+		                Update_FW_One(client, RECOVERY);
+		} else {                        
+		                printk("FW_ID is different!");		
+		}
+*/         	
+		if (FW_ID == 0)  RECOVERY=0x80;
+			Update_FW_One(client, RECOVERY);
+		power_lock = 0;
+
+		work_lock=0;
+		enable_irq(ts->client->irq);
+
+	}
+#endif	
+	return 0;
+
+err_input_register_device_failed:
+	if (ts->input_dev)
+		input_free_device(ts->input_dev);
+
+err_input_dev_alloc_failed: 
+	if (ts->elan_wq)
+		destroy_workqueue(ts->elan_wq);
+
+err_create_wq_failed:
+	kfree(ts);
+
+err_alloc_data_failed:
+err_check_functionality_failed:
+
+	return err;
+}
+
+static int elan_ktf2k_ts_remove(struct i2c_client *client)
+{
+	struct elan_ktf2k_ts_data *ts = i2c_get_clientdata(client);
+
+	elan_touch_sysfs_deinit();
+
+	unregister_early_suspend(&ts->early_suspend);
+	free_irq(client->irq, ts);
+
+	if (ts->elan_wq)
+		destroy_workqueue(ts->elan_wq);
+	input_unregister_device(ts->input_dev);
+	kfree(ts);
+
+	return 0;
+}
+
+static int elan_ktf2k_ts_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	struct elan_ktf2k_ts_data *ts = i2c_get_clientdata(client);
+	int rc = 0;
+	if(power_lock==0) /* The power_lock can be removed when firmware upgrade procedure will not be enter into suspend mode.  */
+	{
+		printk(KERN_INFO "[elan] %s: enter\n", __func__);
+
+		disable_irq(client->irq);
+
+		rc = cancel_work_sync(&ts->work);
+		if (rc)
+			enable_irq(client->irq);
+
+		rc = elan_ktf2k_ts_set_power_state(client, PWR_STATE_DEEP_SLEEP);
+	}
+	return 0;
+}
+
+static int elan_ktf2k_ts_resume(struct i2c_client *client)
+{
+
+	int rc = 0, retry = 3;
+	if(power_lock==0)   /* The power_lock can be removed when firmware upgrade procedure will not be enter into suspend mode.  */
+	{
+		printk(KERN_INFO "[elan] %s: enter\n", __func__);
+
+		do {
+			rc = elan_ktf2k_ts_set_power_state(client, PWR_STATE_NORMAL);
+			mdelay(200);
+			rc = elan_ktf2k_ts_get_power_state(client);
+			if (rc != PWR_STATE_NORMAL)
+				printk(KERN_ERR "[elan] %s: wake up tp failed! err = %d\n",
+					__func__, rc);
+			else
+				break;
+		} while (--retry);
+
+		enable_irq(client->irq);
+	}
+	return 0;
+}
+
+static const struct i2c_device_id elan_ktf2k_ts_id[] = {
+	{ ELAN_KTF2K_NAME, 0 },
+	{ }
+};
+
+static struct i2c_driver ektf2k_ts_driver = {
+	.probe		= elan_ktf2k_ts_probe,
+	.remove		= elan_ktf2k_ts_remove,
+//	.suspend	= elan_ktf2k_ts_suspend,
+//	.resume		= elan_ktf2k_ts_resume,
+	.id_table	= elan_ktf2k_ts_id,
+	.driver		= {
+	.name = ELAN_KTF2K_NAME,
+	},
+};
+
+static int __init elan_ktf2k_ts_init(void)
+{
+	printk(KERN_INFO "[elan] %s driver version 0x0005: Integrated 1, 2, 5, and 10 fingers together and auto-mapping resolution - Developmente By INTI\n", __func__);
+	return i2c_add_driver(&ektf2k_ts_driver);
+}
+
+static void __exit elan_ktf2k_ts_exit(void)
+{
+	i2c_del_driver(&ektf2k_ts_driver);
+	return;
+}
+
+module_init(elan_ktf2k_ts_init);
+module_exit(elan_ktf2k_ts_exit);
+
+MODULE_DESCRIPTION("ELAN KTF2K Touchscreen Driver");
+MODULE_LICENSE("GPL");
+
+
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index 92aa563..f674454 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -454,6 +454,13 @@ config MFD_MAX17135
 	  This is the MAX17135 PMIC support. It includes
 	  core support for communication with the MAX17135 chip.
 
+config MFD_TPS6518X
+    tristate "Texas Instruments TPS6518X EPD PMIC core"
+        depends on I2C
+    help
+      This is the TPS6518X PMIC support. It includes
+      core support for communication with the TPS6518X chip.
+
 config MFD_MAX77686
 	bool "Maxim Semiconductor MAX77686/802 PMIC Support"
 	depends on I2C=y
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index eba844c..7d4c658 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -116,6 +116,7 @@ obj-$(CONFIG_MFD_DA9063)	+= da9063.o
 obj-$(CONFIG_MFD_DA9150)	+= da9150-core.o
 obj-$(CONFIG_MFD_MAX14577)	+= max14577.o
 obj-$(CONFIG_MFD_MAX17135)	+= max17135-core.o
+obj-$(CONFIG_MFD_TPS6518X)  += tps6518x-core.o
 obj-$(CONFIG_MFD_MAX77686)	+= max77686.o
 obj-$(CONFIG_MFD_MAX77693)	+= max77693.o
 obj-$(CONFIG_MFD_MAX77843)	+= max77843.o
diff --git a/drivers/mfd/tps6518x-core.c b/drivers/mfd/tps6518x-core.c
new file mode 100644
index 0000000..35d280c
--- /dev/null
+++ b/drivers/mfd/tps6518x-core.c
@@ -0,0 +1,304 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+/*!
+ * @file pmic/core/tps6518x.c
+ * @brief This file contains TPS6518x specific PMIC code. This implementaion
+ * may differ for each PMIC chip.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*
+ * Includes
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/uaccess.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+
+#include <linux/platform_device.h>
+#include <linux/regulator/machine.h>
+#include <linux/pmic_status.h>
+#include <linux/mfd/core.h>
+#include <linux/mfd/tps6518x.h>
+#include <asm/mach-types.h>
+
+static int tps6518x_detect(struct i2c_client *client, struct i2c_board_info *info);
+struct i2c_client *tps6518x_client;
+static struct regulator *gpio_regulator;
+
+static struct mfd_cell tps6518x_devs[] = {
+	{ .name = "tps6518x-pmic", },
+	{ .name = "tps6518x-sns", },
+};
+
+static const unsigned short normal_i2c[] = {EPDC_PMIC_I2C_ADDR, I2C_CLIENT_END};
+
+int tps6518x_reg_read(int reg_num, unsigned int *reg_val)
+{
+	int result;
+
+	if (tps6518x_client == NULL)
+		return PMIC_ERROR;
+
+	result = i2c_smbus_read_byte_data(tps6518x_client, reg_num);
+	if (result < 0) {
+//		dev_err(&tps6518x_client->dev,
+//			"Unable to read tps6518x register via I2C\n");
+//		printk("tps6518x_  Error read, Address=%u  registro=%u\n",&tps6518x_client->addr,reg_num);
+		return PMIC_ERROR;
+	}
+	
+	*reg_val = result;
+	return PMIC_SUCCESS;
+}
+
+int tps6518x_reg_write(int reg_num, const unsigned int reg_val)
+{
+	int result;
+
+	if (tps6518x_client == NULL)
+		return PMIC_ERROR;
+
+	result = i2c_smbus_write_byte_data(tps6518x_client, reg_num, reg_val);
+	if (result < 0) {
+		dev_err(&tps6518x_client->dev,
+			"Unable to write TPS6518x register via I2C\n");
+//		printk("tps6518x_ ERROR Write - tps6518x_reg_write in tps6518x-core, Address= %u  reg= %u valor= %u\n",
+//		&tps6518x_client->addr,reg_num, reg_val);
+		return PMIC_ERROR;
+	}
+//	printk("tps6518x_ OK Write - tps6518x_reg_write in tps6518x-core, Address= %u  reg= %u valor= %u\n",
+//		&tps6518x_client->addr,reg_num, reg_val);
+	return PMIC_SUCCESS;
+}
+
+#ifdef CONFIG_OF
+static struct tps6518x_platform_data *tps6518x_i2c_parse_dt_pdata(
+					struct device *dev)
+{
+	struct tps6518x_platform_data *pdata;
+
+	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata) {
+		dev_err(dev, "could not allocate memory for pdata\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	return pdata;
+}
+#else
+static struct tps6518x_platform_data *tps6518x_i2c_parse_dt_pdata(
+					struct device *dev)
+{
+	return NULL;
+}
+#endif	/* !CONFIG_OF */
+
+static int tps6518x_probe(struct i2c_client *client,
+			    const struct i2c_device_id *id)
+{
+	struct tps6518x *tps6518x;
+	struct tps6518x_platform_data *pdata = client->dev.platform_data;
+	struct device_node *np = client->dev.of_node;
+	int ret = 0;
+
+	printk("Start probe calling for tps6518x - INTI-CMNB \n");
+
+	if (!np)
+		return -ENODEV;
+
+	gpio_regulator = devm_regulator_get(&client->dev, "SENSOR");
+	if (!IS_ERR(gpio_regulator)) {
+		ret = regulator_enable(gpio_regulator);
+		if (ret) {
+			dev_err(&client->dev, "gpio set voltage error\n");
+			return ret;
+		}
+	}
+
+
+	/* Create the PMIC data structure */
+	tps6518x = kzalloc(sizeof(struct tps6518x), GFP_KERNEL);
+	if (tps6518x == NULL) {
+		kfree(client);
+		return -ENOMEM;
+	}
+
+	/* Initialize the PMIC data structure */
+	i2c_set_clientdata(client, tps6518x);
+	tps6518x->dev = &client->dev;
+	tps6518x->i2c_client = client;
+
+	tps6518x_client = client;
+	ret = tps6518x_detect(client, NULL);
+	if (ret)
+		goto err1;
+
+	mfd_add_devices(tps6518x->dev, -1, tps6518x_devs,
+			ARRAY_SIZE(tps6518x_devs),
+			NULL, 0, NULL);
+
+	if (tps6518x->dev->of_node) {
+		pdata = tps6518x_i2c_parse_dt_pdata(tps6518x->dev);
+		if (IS_ERR(pdata)) {
+			ret = PTR_ERR(pdata);
+			goto err2;
+		}
+
+	}
+	tps6518x->pdata = pdata;
+	/* Set Power Good Polarity for BombShellv2 HW */
+	tps6518x->pwrgood_polarity=1;
+	dev_info(&client->dev, "PMIC TPS6518x for eInk display \n");
+
+	printk("tps6518x_probe success\n");
+
+	return ret;
+
+err2:
+	mfd_remove_devices(tps6518x->dev);
+err1:
+	kfree(tps6518x);
+
+	return ret;
+}
+
+
+static int tps6518x_remove(struct i2c_client *i2c)
+{
+	struct tps6518x *tps6518x = i2c_get_clientdata(i2c);
+
+	mfd_remove_devices(tps6518x->dev);
+
+	return 0;
+}
+
+static int tps6518x_suspend(struct i2c_client *client, pm_message_t state)
+{
+	return 0;
+}
+
+static int tps6518x_resume(struct i2c_client *client)
+{
+	return 0;
+}
+
+/* Return 0 if detection is successful, -ENODEV otherwise */
+static int tps6518x_detect(struct i2c_client *client,
+			  struct i2c_board_info *info)
+{
+	//struct tps6518x_platform_data *pdata = client->dev.platform_data;
+	struct i2c_adapter *adapter = client->adapter;
+	u8 revId;
+    printk("tps6518x_detect calling\n");
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))
+		return -ENODEV;
+
+	/* identification */
+	revId = i2c_smbus_read_byte_data(client,
+		  REG_TPS6518x_REVID);
+
+	/*
+	 * Known rev-ids
+	 * tps165180 pass 1 = 0x50, tps65180 pass2 = 0x60, tps65181 pass1 = 0x51, tps65181 pass2 = 0x61, 
+	 * tps65182, 
+	 * tps65185 pass0 = 0x45, tps65186 pass0 0x46, tps65185 pass1 = 0x55, tps65186 pass1 0x56, tps65185 pass2 = 0x65, tps65186 pass2 0x66, add revID= 0xFB BombShell v2 HW
+	 */
+	if (!((revId == TPS65180_PASS1) ||
+		 (revId == TPS65181_PASS1) ||
+		 (revId == TPS65180_PASS2) ||
+		 (revId == TPS65181_PASS2) ||
+		 (revId == TPS65185_PASS0) ||
+		 (revId == TPS65186_PASS0) ||
+		 (revId == TPS65185_PASS1) ||
+		 (revId == TPS65186_PASS1) ||
+		 (revId == TPS65185_PASS2) ||
+		 (revId == TPS65186_PASS2)))
+	{
+		dev_info(&adapter->dev,
+		    "Unsupported chip (Revision ID=0x%02X).\n",  revId);
+		return -ENODEV;
+	}
+
+	if (info) {
+		strlcpy(info->type, "tps6518x_sensor", I2C_NAME_SIZE);
+	}
+    //printk("tps6518x_ Detect success! revId==0x%02X \n", revId);
+
+	return 0;
+}
+
+static const struct i2c_device_id tps6518x_id[] = {
+	{ "tps6518x", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, tps6518x_id);
+
+static const struct of_device_id tps6518x_dt_ids[] = {
+	{
+		.compatible = "ti,tps6518x",
+		.data = (void *) &tps6518x_id[0],
+	}, {
+		/* sentinel */
+	}
+};
+MODULE_DEVICE_TABLE(of, tps6518x_dt_ids);
+
+
+static struct i2c_driver tps6518x_driver = {
+	.driver = {
+		   .name = "tps6518x",
+		   .owner = THIS_MODULE,
+		   .of_match_table = tps6518x_dt_ids,
+	},
+	.probe = tps6518x_probe,
+	.remove = tps6518x_remove,
+//	.suspend = tps6518x_suspend,
+//	.resume = tps6518x_resume,
+	.id_table = tps6518x_id,
+	.detect = tps6518x_detect,
+	.address_list = &normal_i2c[0],
+};
+
+static int __init tps6518x_init(void)
+{
+	return i2c_add_driver(&tps6518x_driver);
+}
+
+static void __exit tps6518x_exit(void)
+{
+	i2c_del_driver(&tps6518x_driver);
+}
+
+/*
+ * Module entry points
+ */
+subsys_initcall(tps6518x_init);
+module_exit(tps6518x_exit);
diff --git a/drivers/regulator/Kconfig b/drivers/regulator/Kconfig
index f75aee2..31ee7f0 100644
--- a/drivers/regulator/Kconfig
+++ b/drivers/regulator/Kconfig
@@ -328,6 +328,10 @@ config REGULATOR_MAX17135
 	tristate "Maxim MAX17135 Regulator Support"
 	depends on MFD_MAX17135
 
+config REGULATOR_TPS6518X
+        tristate "Texas Instruments TPS6518X Regulator Support"
+        depends on MFD_TPS6518X
+
 config REGULATOR_MAX8649
 	tristate "Maxim 8649 voltage regulator"
 	depends on I2C
diff --git a/drivers/regulator/Makefile b/drivers/regulator/Makefile
index fe4fea7..3eb626b 100644
--- a/drivers/regulator/Makefile
+++ b/drivers/regulator/Makefile
@@ -45,6 +45,7 @@ obj-$(CONFIG_REGULATOR_LTC3589) += ltc3589.o
 obj-$(CONFIG_REGULATOR_MAX14577) += max14577.o
 obj-$(CONFIG_REGULATOR_MAX1586) += max1586.o
 obj-$(CONFIG_REGULATOR_MAX17135) += max17135-regulator.o
+obj-$(CONFIG_REGULATOR_TPS6518X) += tps6518x-regulator.o
 obj-$(CONFIG_REGULATOR_MAX8649)	+= max8649.o
 obj-$(CONFIG_REGULATOR_MAX8660) += max8660.o
 obj-$(CONFIG_REGULATOR_MAX8907) += max8907-regulator.o
diff --git a/drivers/regulator/tps6518x-regulator.c b/drivers/regulator/tps6518x-regulator.c
new file mode 100644
index 0000000..66e326c
--- /dev/null
+++ b/drivers/regulator/tps6518x-regulator.c
@@ -0,0 +1,890 @@
+
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/of_regulator.h>
+#include <linux/mfd/tps6518x.h>
+#include <linux/gpio.h>
+#include <linux/pmic_status.h>
+#include <linux/of_gpio.h>
+
+struct tps6518x_data {
+	int num_regulators;
+	struct tps6518x *tps6518x;
+	struct regulator_dev **rdev;
+};
+
+
+static int tps6518x_pass_num = { 2 };
+static int tps6518x_vcom = { -2680000 };
+static int tps65180_current_Enable_Register = 0;
+
+static int tps6518x_is_power_good(struct tps6518x *tps6518x);
+/*
+ * to_reg_val(): Creates a register value with new data
+ *
+ * Creates a new register value for a particular field.  The data
+ * outside of the new field is not modified.
+ *
+ * @cur_reg: current value in register
+ * @reg_mask: mask of field bits to be modified
+ * @fld_val: new value for register field.
+ */
+static unsigned int to_reg_val(unsigned int cur_reg, unsigned int fld_mask,
+							   unsigned int fld_val)
+{
+	return (cur_reg & (~fld_mask)) | fld_val;
+}
+
+/*
+ * Regulator operations
+ */
+/* Convert uV to the VCOM register bitfield setting */
+
+static int vcom_rs_to_uV(unsigned int reg_setting)
+{
+	if (reg_setting <= TPS65180_VCOM_MIN_SET)
+		return TPS65180_VCOM_MIN_uV;
+	if (reg_setting >= TPS65180_VCOM_MAX_SET)
+		return TPS65180_VCOM_MAX_uV;
+	return -(reg_setting * TPS65180_VCOM_STEP_uV);
+}
+static int vcom2_rs_to_uV(unsigned int reg_setting)
+{
+	if (reg_setting <= TPS65185_VCOM_MIN_SET)
+		return TPS65185_VCOM_MIN_uV;
+	if (reg_setting >= TPS65185_VCOM_MAX_SET)
+		return TPS65185_VCOM_MAX_uV;
+	return -(reg_setting * TPS65185_VCOM_STEP_uV);
+}
+
+
+static int vcom_uV_to_rs(int uV)
+{
+	if (uV <= TPS65180_VCOM_MIN_uV)
+		return TPS65180_VCOM_MIN_SET;
+	if (uV >= TPS65180_VCOM_MAX_uV)
+		return TPS65180_VCOM_MAX_SET;
+	return (-uV) / TPS65180_VCOM_STEP_uV;
+}
+
+static int vcom2_uV_to_rs(int uV)
+{
+	if (uV <= TPS65185_VCOM_MIN_uV)
+		return TPS65185_VCOM_MIN_SET;
+	if (uV >= TPS65185_VCOM_MAX_uV)
+		return TPS65185_VCOM_MAX_SET;
+	return (-uV) / TPS65185_VCOM_STEP_uV;
+}
+
+static int epdc_pwr0_enable(struct regulator_dev *reg)
+{
+	struct tps6518x *tps6518x = rdev_get_drvdata(reg);
+
+	gpio_set_value(tps6518x->gpio_pmic_powerup, 1);
+
+	return 0;
+
+}
+
+static int epdc_pwr0_disable(struct regulator_dev *reg)
+{
+	struct tps6518x *tps6518x = rdev_get_drvdata(reg);
+
+	gpio_set_value(tps6518x->gpio_pmic_powerup, 0);
+
+	return 0;
+
+}
+static int tps6518x_v3p3_enable(struct regulator_dev *reg)
+{
+	struct tps6518x *tps6518x = rdev_get_drvdata(reg);
+//	printk ("tps6518x_ Regulator V3P3 Enable - powerUp 1 line127\n\n");
+	gpio_set_value(tps6518x->gpio_pmic_powerup, 1);
+	return 0;
+}
+
+static int tps6518x_v3p3_disable(struct regulator_dev *reg)
+{
+	struct tps6518x *tps6518x = rdev_get_drvdata(reg);
+//	printk ("tps6518x_ Regulator V3P3 Disable - powerUp 0 line136\n\n");
+	gpio_set_value(tps6518x->gpio_pmic_powerup, 0);
+	return 0;
+
+}
+static int tps6518x_v3p3_is_enabled(struct regulator_dev *reg)
+{
+	struct tps6518x *tps6518x = rdev_get_drvdata(reg);
+	int gpio = gpio_get_value(tps6518x->gpio_pmic_powerup);
+
+	if (gpio == 0)
+		return 0;
+	else
+		return 1;
+}
+
+static int tps6518x_vcom_set_voltage(struct regulator_dev *reg,
+					int minuV, int uV, unsigned *selector)
+{
+	struct tps6518x *tps6518x = rdev_get_drvdata(reg);
+	unsigned int cur_reg_val; /* current register value to modify */
+	unsigned int new_reg_val; /* new register value to write */
+	int retval;
+
+	/*
+	 * this will not work on tps65182
+	 */
+	if (tps6518x->revID == 65182)
+		return 0;
+	
+#if 0
+	if (uV < 200000)
+		return 0;
+#endif
+//	printk("tps6518x_ Funcion VCOM_set_voltage ID=%u \n",tps6518x->revID);	
+	switch (tps6518x->revID & 15)
+	{
+		case 0 : /* TPS65185 - BombSHELL */	
+			gpio_set_value(tps6518x->gpio_pmic_wakeup,1);
+			retval = tps6518x_reg_write(REG_TPS65185_VCOM1,
+					vcom2_uV_to_rs(uV) & 255);
+			tps6518x_reg_read( REG_TPS65185_VCOM2,&cur_reg_val);
+			new_reg_val = to_reg_val(cur_reg_val,
+					BITFMASK(VCOM2_SET),
+					BITFVAL(VCOM2_SET, vcom2_uV_to_rs(uV)/256));
+
+			retval = tps6518x_reg_write(REG_TPS65185_VCOM2,
+					new_reg_val);
+//			printk("tps6518x_ VCOM_set_voltage CASE:0  value=%d\n",retval);
+			break;
+		case 1 : /* TPS65181 */
+		case 4 : /* TPS65180-rev1 */
+			tps6518x_reg_read(REG_TPS65180_VCOM_ADJUST,&cur_reg_val);
+			new_reg_val = to_reg_val(cur_reg_val,
+					BITFMASK(VCOM_SET),
+					BITFVAL(VCOM_SET, vcom_uV_to_rs(uV)));
+
+			retval = tps6518x_reg_write(REG_TPS65180_VCOM_ADJUST,
+					new_reg_val);
+			break;
+		case 5 : /* TPS65185 */
+		case 6 : /* TPS65186 */
+//			printk("tps6518x_ VCOM_set_voltage CASE:6 \n");	
+			gpio_set_value(tps6518x->gpio_pmic_wakeup,1);
+			retval = tps6518x_reg_write(REG_TPS65185_VCOM1,
+					vcom2_uV_to_rs(uV) & 255);
+			tps6518x_reg_read( REG_TPS65185_VCOM2,&cur_reg_val);
+			new_reg_val = to_reg_val(cur_reg_val,
+					BITFMASK(VCOM2_SET),
+					BITFVAL(VCOM2_SET, vcom2_uV_to_rs(uV)/256));
+
+			retval = tps6518x_reg_write(REG_TPS65185_VCOM2,
+					new_reg_val);
+//			printk("tps6518x_ VCOM_set_voltage CASE:6  value=%d\n",retval);
+			break;
+		default :
+		retval = -1;
+	}
+	return retval;
+}
+
+static int tps6518x_vcom_get_voltage(struct regulator_dev *reg)
+{
+	struct tps6518x *tps6518x = rdev_get_drvdata(reg);
+	unsigned int cur_reg_val; /* current register value */
+	unsigned int cur_reg2_val; /* current register value */
+	unsigned int cur_fld_val; /* current bitfield value*/
+	int vcomValue;
+
+	/*
+	 * this will not work on tps65182
+	 */
+	if (tps6518x->revID == 65182)
+		return 0;
+//	printk("tps6518x_ VCOM_get_voltage Function ID=%u \n",tps6518x->revID);	
+	switch (tps6518x->revID & 15)
+	{
+		case 0 : /* TPS65185 - bOMBsHELL */	
+			tps6518x_reg_read(REG_TPS65185_VCOM1,&cur_reg_val);
+			tps6518x_reg_read(REG_TPS65185_VCOM2,&cur_reg2_val);
+			cur_reg_val |= 256 * (1 & cur_reg2_val);
+			vcomValue = vcom2_rs_to_uV(cur_reg_val);
+//			printk("tps6518x_ VCOM_Get_voltage CASE:0 value= %d \n",vcomValue);
+			break;
+		case 1 : /* TPS65181 */
+		case 4 : /* TPS65180-rev1 */
+			tps6518x_reg_read(REG_TPS65180_VCOM_ADJUST, &cur_reg_val);
+			cur_fld_val = BITFEXT(cur_reg_val, VCOM_SET);
+			vcomValue = vcom_rs_to_uV(cur_fld_val);
+			break;
+		case 5 : /* TPS65185 */
+		case 6 : /* TPS65186 */
+//			printk("tps6518x_ VCOM_Get_voltage CASE:6 \n");	
+			tps6518x_reg_read(REG_TPS65185_VCOM1,&cur_reg_val);
+			tps6518x_reg_read(REG_TPS65185_VCOM2,&cur_reg2_val);
+			cur_reg_val |= 256 * (1 & cur_reg2_val);
+			vcomValue = vcom2_rs_to_uV(cur_reg_val);
+			break;
+		default:
+			vcomValue = 0;
+	}
+	
+	return vcomValue;
+
+}
+
+static int tps6518x_vcom_enable(struct regulator_dev *reg)
+{
+	struct tps6518x *tps6518x = rdev_get_drvdata(reg);
+	unsigned int cur_reg_val; /* current register value */
+	int vcomEnable = 0;
+	int fault;
+	/*
+	 * check for the TPS65182 device
+	 */
+	if (tps6518x->revID == 65182)
+	{
+		gpio_set_value(tps6518x->gpio_pmic_vcom_ctrl,vcomEnable);
+		return 0;
+	}
+	printk("tps6518x_ Entro en VCOM_enable() RevID:  %u\n",tps6518x->revID);
+	/*
+	 * Check to see if we need to set the VCOM voltage.
+	 * Should only be done one time. And, we can
+	 * only change vcom voltage if we have been enabled.
+	 */
+	if (!tps6518x->vcom_setup && tps6518x_is_power_good(tps6518x)) { //tira vcom_SEtup=0 y tps_PWR-GOOD=1, OK!
+//		printk("tps6518x_ Entro en IF VCOM_enable() vcom_SEtup=%u y tps_PWR-GOOD=%u\n",tps6518x->vcom_setup,tps6518x_is_power_good(tps6518x));		
+		tps6518x_vcom_set_voltage(reg,
+			tps6518x->vcom_uV,
+			tps6518x->vcom_uV,
+			NULL);
+		tps6518x->vcom_setup = true;
+	}
+		
+	switch (tps6518x->revID & 15)
+	{
+		case 0 : /* TPS65180 - BombShell*/
+			tps6518x_reg_read(REG_TPS65185_VCOM2,&cur_reg_val);
+//			printk("tps6518x_ VCOM2 current value = %u \n",cur_reg_val);			
+			// do not enable vcom if HiZ bit is set
+			if (cur_reg_val & (1<<VCOM_HiZ_LSH))
+			{
+				printk("tps6518x_ Do not enable VCOM_enable CASE:0 \n");			
+				vcomEnable = 0;
+			}else{
+				vcomEnable = 1;
+				printk("tps6518x_ Enable VCOM_enable  CASE:0 value=%d \n",vcomEnable);				
+				}			
+			break;
+		case 1 : /* TPS65181 */
+		case 4 : /* TPS65180-rev1 */
+			vcomEnable = 1;
+			break;
+		case 5 : /* TPS65185 */
+		case 6 : /* TPS65186 */
+			tps6518x_reg_read(REG_TPS65185_VCOM2,&cur_reg_val);
+			// do not enable vcom if HiZ bit is set
+			if (cur_reg_val & (1<<VCOM_HiZ_LSH))
+			{
+//				printk("tps6518x_ Do not enable VCOM CASE:6 \n");			
+				vcomEnable = 0;
+			}else{
+				vcomEnable = 1;
+//				printk("tps6518x_ Enable VCOM  CASE:6\n");				
+				}			
+			break;
+		default:
+			vcomEnable = 0;
+	}
+	gpio_set_value(tps6518x->gpio_pmic_vcom_ctrl,vcomEnable);
+
+	tps6518x_reg_read(REG_TPS65185_INT2,&fault);
+	
+	if(fault!=0)
+		printk("tps6518x_ Error vcom_enable(); Reg.0x08 (INT2), value= %d \n",fault);	
+
+	return 0;
+}
+
+static int tps6518x_vcom_disable(struct regulator_dev *reg)
+{
+	struct tps6518x *tps6518x = rdev_get_drvdata(reg);
+//	printk("tps6518x_ Disable VCOM \n");
+	gpio_set_value(tps6518x->gpio_pmic_vcom_ctrl,0);
+	return 0;
+}
+
+static int tps6518x_vcom_is_enabled(struct regulator_dev *reg)
+{
+	struct tps6518x *tps6518x = rdev_get_drvdata(reg);
+
+	int gpio = gpio_get_value(tps6518x->gpio_pmic_vcom_ctrl);
+	if (gpio == 0)
+		return 0;
+	else
+		return 1;
+}
+
+static int tps6518x_is_power_good(struct tps6518x *tps6518x)
+{
+	/*
+	 * XOR of polarity (starting value) and current
+	 * value yields whether power is good.
+	 */
+	
+//	printk("tps6518x_ Check pmic_pwrgood GPIO ori_polarity=%d, pmic_pwrgood=%d Return=%d \n",
+//	tps6518x->pwrgood_polarity,tps6518x->gpio_pmic_pwrgood,(gpio_get_value(tps6518x->gpio_pmic_pwrgood) ^
+//	tps6518x->pwrgood_polarity));
+
+	return gpio_get_value(tps6518x->gpio_pmic_pwrgood) ^
+		tps6518x->pwrgood_polarity; //set 1 Xor 1-1=0 fails y 0-1=1 in regulation mode
+}
+
+static int tps6518x_wait_power_good(struct tps6518x *tps6518x)
+{
+	int i;
+	for (i = 0; i < tps6518x->max_wait * 3; i++) {
+		if (tps6518x_is_power_good(tps6518x))
+			return 0;
+		
+		msleep(1);
+	}
+	return -ETIMEDOUT;
+}
+
+static int tps6518x_display_enable(struct regulator_dev *reg)
+{
+	struct tps6518x *tps6518x = rdev_get_drvdata(reg);
+	unsigned int cur_reg_val; /* current register value to modify */
+	unsigned int fld_mask;	  /* register mask for bitfield to modify */
+	unsigned int fld_val;	  /* new bitfield value to write */
+	unsigned int new_reg_val; /* new register value to write */
+	int fault; 	/*fault INT1 INT2 */
+	
+	if (tps6518x->revID == 65182)
+	{
+		epdc_pwr0_enable(reg);
+//		printk("tps6518x_ iF Display_enable... \n");	
+	}
+	else
+	{
+//		printk("tps6518x_ ELSE display_enable.... \n");
+		gpio_set_value(tps6518x->gpio_pmic_wakeup,1);
+		msleep(1);
+
+		/* enable display regulators */
+		cur_reg_val = tps65180_current_Enable_Register & 0x3f;
+		fld_mask = BITFMASK(VCOM_EN) | BITFMASK(VDDH_EN) |     
+			BITFMASK(VPOS_EN) | BITFMASK(VEE_EN) | BITFMASK(VNEG_EN); 	// add VCOM_EN,V3P3_EN mask
+		fld_val =  BITFVAL(VCOM_EN, true) | 	
+			BITFVAL(VDDH_EN, true) | BITFVAL(VPOS_EN, true) | BITFVAL(VEE_EN, true) | BITFVAL(VNEG_EN, true);	
+		new_reg_val = tps65180_current_Enable_Register = to_reg_val(cur_reg_val, fld_mask, fld_val);
+		tps6518x_reg_write(REG_TPS65185_ENABLE, new_reg_val); 	// baja 00111111
+		
+		msleep(1);
+//		printk("tps6518x_ primer write registro reg=%u - valor=%u \n\n",REG_TPS65185_ENABLE,new_reg_val,new_reg_val);
+
+	/*TODO - 	
+	The integrated power switch is used to cut the 3.3-V supply to the EPD panel and is controlled through the
+	V3P3_EN pin of the ENABLE register. In SLEEP mode the switch is automatically turned off and its output is
+	discharged to ground. The default power-up state is OFF. To turn the switch ON, set the V3P3_ENbit to 1.*/
+
+		/* turn on display regulators */
+		cur_reg_val = tps65180_current_Enable_Register & 0x3f;
+		fld_mask = BITFMASK(ACTIVE); 	
+		fld_val = BITFVAL(ACTIVE, true); 
+		new_reg_val = tps65180_current_Enable_Register = to_reg_val(cur_reg_val, fld_mask, fld_val); 
+		tps6518x_reg_write(REG_TPS65185_ENABLE, new_reg_val); 	// set AcTIVE to "1"- baja 10011111
+	}
+
+	msleep(1);
+	tps6518x_reg_read(REG_TPS65185_INT1,&fault);
+	if (fault!=0)
+		printk("tps6518x_ Error Reg.0x07 (INT1), value= %d \n",fault);
+	tps6518x_reg_read(REG_TPS65185_INT2,&fault);
+	if(fault!=0)
+		printk("tps6518x_ Error Reg.0x08 (INT2), value= %d \n",fault);	
+
+	return tps6518x_wait_power_good(tps6518x);
+}
+
+static int tps6518x_display_disable(struct regulator_dev *reg)
+{
+	struct tps6518x *tps6518x = rdev_get_drvdata(reg);
+	unsigned int cur_reg_val; /* current register value to modify */
+	unsigned int fld_mask;	  /* register mask for bitfield to modify */
+	unsigned int fld_val;	  /* new bitfield value to write */
+	unsigned int new_reg_val; /* new register value to write */
+
+	if (tps6518x->revID == 65182)
+	{
+		epdc_pwr0_disable(reg);
+	}
+	else
+	{
+		/* turn off display regulators */
+		cur_reg_val = tps65180_current_Enable_Register & 0x3f;
+		fld_mask = BITFMASK(VCOM_EN) | BITFMASK(STANDBY);
+		fld_val = BITFVAL(VCOM_EN, true) | BITFVAL(STANDBY, true);
+		new_reg_val = tps65180_current_Enable_Register = to_reg_val(cur_reg_val, fld_mask, fld_val);
+		tps6518x_reg_write(REG_TPS65180_ENABLE, new_reg_val);
+		//gpio_set_value(tps6518x->gpio_pmic_powerup,0);	//add
+//		printk("tps6518x_ disable, EPDC DIsplay dir=%u val= %u  line443\n",REG_TPS65180_ENABLE, new_reg_val);
+	}
+
+	msleep(tps6518x->max_wait);
+
+	return 0;
+}
+
+static int tps6518x_display_is_enabled(struct regulator_dev *reg)
+{
+	struct tps6518x *tps6518x = rdev_get_drvdata(reg);
+
+	if (tps6518x->revID == 65182)
+		return gpio_get_value(tps6518x->gpio_pmic_wakeup) ? 1:0;
+	else
+		return tps65180_current_Enable_Register & BITFMASK(ACTIVE);
+}
+
+/*
+ * Regulator operations
+ */
+
+static struct regulator_ops tps6518x_display_ops = {
+	.enable = tps6518x_display_enable,
+	.disable = tps6518x_display_disable,
+	.is_enabled = tps6518x_display_is_enabled,
+};
+
+static struct regulator_ops tps6518x_vcom_ops = {
+	.enable = tps6518x_vcom_enable,
+	.disable = tps6518x_vcom_disable,
+	.get_voltage = tps6518x_vcom_get_voltage,
+	.set_voltage = tps6518x_vcom_set_voltage,
+	.is_enabled = tps6518x_vcom_is_enabled,
+};
+
+static struct regulator_ops tps6518x_v3p3_ops = {
+	.enable = tps6518x_v3p3_enable,
+	.disable = tps6518x_v3p3_disable,
+	.is_enabled = tps6518x_v3p3_is_enabled,
+};
+
+/*
+ * Regulator descriptors
+ */
+static struct regulator_desc tps6518x_reg[TPS6518x_NUM_REGULATORS] = {
+{
+	.name = "DISPLAY",
+	.id = TPS6518x_DISPLAY,
+	.ops = &tps6518x_display_ops,
+	.type = REGULATOR_VOLTAGE,
+	.owner = THIS_MODULE,
+},
+{
+	.name = "VCOM",
+	.id = TPS6518x_VCOM,
+	.ops = &tps6518x_vcom_ops,
+	.type = REGULATOR_VOLTAGE,
+	.owner = THIS_MODULE,
+},
+{
+	.name = "V3P3",
+	.id = TPS6518x_V3P3,
+	.ops = &tps6518x_v3p3_ops,
+	.type = REGULATOR_VOLTAGE,
+	.owner = THIS_MODULE,
+},
+};
+
+static void tps6518x_setup_timings(struct tps6518x *tps6518x)
+{
+
+	int temp0, temp1, temp2, temp3;
+
+	/* read the current setting in the PMIC */
+	if ((tps6518x->revID == TPS65180_PASS1) || (tps6518x->revID == TPS65181_PASS1) ||
+	   (tps6518x->revID == TPS65180_PASS2) || (tps6518x->revID == TPS65181_PASS2)) {
+	   tps6518x_reg_read(REG_TPS65180_PWRSEQ0, &temp0);
+	   tps6518x_reg_read(REG_TPS65180_PWRSEQ1, &temp1);
+	   tps6518x_reg_read(REG_TPS65180_PWRSEQ2, &temp2);
+
+	   if ((temp0 != tps6518x->pwr_seq0) ||
+		(temp1 != tps6518x->pwr_seq1) ||
+		(temp2 != tps6518x->pwr_seq2)) {
+		tps6518x_reg_write(REG_TPS65180_PWRSEQ0, tps6518x->pwr_seq0);
+		tps6518x_reg_write(REG_TPS65180_PWRSEQ1, tps6518x->pwr_seq1);
+		tps6518x_reg_write(REG_TPS65180_PWRSEQ2, tps6518x->pwr_seq2);
+		printk("tps6518x_ tps65180 - setup timmings= %d, %d, %d, \n",tps6518x->pwr_seq0,
+tps6518x->pwr_seq1,tps6518x->pwr_seq2);	    
+		}
+	}
+
+	if ((tps6518x->revID == TPS65185_PASS0) ||
+		 (tps6518x->revID == TPS65186_PASS0) ||
+		 (tps6518x->revID == TPS65185_PASS1) ||
+		 (tps6518x->revID == TPS65186_PASS1) ||
+		 (tps6518x->revID == TPS65185_PASS2) ||
+		 (tps6518x->revID == TPS65186_PASS2)) {
+	   tps6518x_reg_read(REG_TPS65185_UPSEQ0, &temp0);
+	   tps6518x_reg_read(REG_TPS65185_UPSEQ1, &temp1);
+	   tps6518x_reg_read(REG_TPS65185_DWNSEQ0, &temp2);
+	   tps6518x_reg_read(REG_TPS65185_DWNSEQ1, &temp3);
+	   if ((temp0 != tps6518x->upseq0) ||
+		(temp1 != tps6518x->upseq1) ||
+		(temp2 != tps6518x->dwnseq0) ||
+		(temp3 != tps6518x->dwnseq1)) {
+		tps6518x_reg_write(REG_TPS65185_UPSEQ0, tps6518x->upseq0);
+		tps6518x_reg_write(REG_TPS65185_UPSEQ1, tps6518x->upseq1);
+		tps6518x_reg_write(REG_TPS65185_DWNSEQ0, tps6518x->dwnseq0);
+		tps6518x_reg_write(REG_TPS65185_DWNSEQ1, tps6518x->dwnseq1);
+		printk("tps6518x_ tps65185 - setup timmings= %d, %d, %d, %d, \n",tps6518x->upseq0,tps6518x->upseq1,
+tps6518x->dwnseq0,tps6518x->dwnseq1);	    
+		}
+	}
+}
+
+#define CHECK_PROPERTY_ERROR_KFREE(prop) \
+do { \
+	int ret = of_property_read_u32(tps6518x->dev->of_node, \
+					#prop, &tps6518x->prop); \
+	if (ret < 0) { \
+		return ret;	\
+	}	\
+} while (0);
+
+#ifdef CONFIG_OF
+static int tps6518x_pmic_dt_parse_pdata(struct platform_device *pdev,
+					struct tps6518x_platform_data *pdata)
+{
+	struct tps6518x *tps6518x = dev_get_drvdata(pdev->dev.parent);
+	struct device_node *pmic_np, *regulators_np, *reg_np;
+	struct tps6518x_regulator_data *rdata;
+	int i, ret;
+
+	pmic_np = of_node_get(tps6518x->dev->of_node);
+	if (!pmic_np) {
+		dev_err(&pdev->dev, "could not find pmic sub-node\n");
+		return -ENODEV;
+	}
+
+	regulators_np = of_find_node_by_name(pmic_np, "regulators");
+	if (!regulators_np) {
+		dev_err(&pdev->dev, "could not find regulators sub-node\n");
+		return -EINVAL;
+	}
+
+	pdata->num_regulators = of_get_child_count(regulators_np);
+	dev_dbg(&pdev->dev, "num_regulators %d\n", pdata->num_regulators);
+
+	rdata = devm_kzalloc(&pdev->dev, sizeof(*rdata) *
+				pdata->num_regulators, GFP_KERNEL);
+	if (!rdata) {
+		of_node_put(regulators_np);
+		dev_err(&pdev->dev, "could not allocate memory for"
+			"regulator data\n");
+		return -ENOMEM;
+	}
+
+	pdata->regulators = rdata;
+	for_each_child_of_node(regulators_np, reg_np) {
+		for (i = 0; i < ARRAY_SIZE(tps6518x_reg); i++)
+			if (!of_node_cmp(reg_np->name, tps6518x_reg[i].name))
+				break;
+
+		if (i == ARRAY_SIZE(tps6518x_reg)) {
+			dev_warn(&pdev->dev, "don't know how to configure"
+				"regulator %s\n", reg_np->name);
+			continue;
+		}
+
+		rdata->id = i;
+		//rdata->initdata = of_get_regulator_init_data(&pdev->dev,
+			//				     reg_np);
+		rdata->initdata = of_get_regulator_init_data(&pdev->dev,reg_np, tps6518x_reg); /* BombShell V2 */
+		
+		rdata->reg_node = reg_np;
+		rdata++;
+	}
+	of_node_put(regulators_np);
+
+	tps6518x->max_wait = (6 + 6 + 6 + 6);
+
+	tps6518x->gpio_pmic_wakeup = of_get_named_gpio(pmic_np,
+					"gpio_pmic_wakeup", 0);
+	if (!gpio_is_valid(tps6518x->gpio_pmic_wakeup)) {
+		dev_err(&pdev->dev, "no epdc pmic wakeup pin available\n");
+		goto err;
+	}
+	ret = devm_gpio_request_one(&pdev->dev, tps6518x->gpio_pmic_wakeup,
+				GPIOF_OUT_INIT_LOW, "epdc-pmic-wake");
+	if (ret < 0)
+		goto err;
+
+	tps6518x->gpio_pmic_vcom_ctrl = of_get_named_gpio(pmic_np,
+					"gpio_pmic_vcom_ctrl", 0);
+	if (!gpio_is_valid(tps6518x->gpio_pmic_vcom_ctrl)) {
+		dev_err(&pdev->dev, "no epdc pmic vcom_ctrl pin available\n");
+		goto err;
+	}
+	ret = devm_gpio_request_one(&pdev->dev, tps6518x->gpio_pmic_vcom_ctrl,
+				GPIOF_OUT_INIT_LOW, "epdc-vcom");
+	if (ret < 0)
+		goto err;
+
+	tps6518x->gpio_pmic_powerup = of_get_named_gpio(pmic_np,
+					"gpio_pmic_powerup", 0);
+	if (!gpio_is_valid(tps6518x->gpio_pmic_powerup)) {
+		dev_err(&pdev->dev, "no epdc pmic powerup pin available\n");
+		goto err;
+	}
+	ret = devm_gpio_request_one(&pdev->dev, tps6518x->gpio_pmic_powerup,
+				GPIOF_OUT_INIT_LOW, "epdc-powerup");
+	if (ret < 0)
+		goto err;
+
+	tps6518x->gpio_pmic_intr = of_get_named_gpio(pmic_np,
+					"gpio_pmic_intr", 0);
+	if (!gpio_is_valid(tps6518x->gpio_pmic_intr)) {
+		dev_err(&pdev->dev, "no epdc pmic intr pin available\n");
+		goto err;
+	}
+	ret = devm_gpio_request_one(&pdev->dev, tps6518x->gpio_pmic_intr,
+				GPIOF_IN, "epdc-pmic-int");
+	if (ret < 0)
+		goto err;
+
+	tps6518x->gpio_pmic_pwrgood = of_get_named_gpio(pmic_np,
+					"gpio_pmic_pwrgood", 0);
+	if (!gpio_is_valid(tps6518x->gpio_pmic_pwrgood)) {
+		dev_err(&pdev->dev, "no epdc pmic pwrgood pin available\n");
+		goto err;
+	}
+	ret = devm_gpio_request_one(&pdev->dev, tps6518x->gpio_pmic_pwrgood,
+				GPIOF_IN, "epdc-pwrstat");
+	if (ret < 0)
+		goto err;
+
+err:
+	return 0;
+
+}
+#else
+static int tps6518x_pmic_dt_parse_pdata(struct platform_device *pdev,
+					struct tps6518x *tps6518x)
+{
+	return 0;
+}
+#endif	/* !CONFIG_OF */
+
+/*
+ * Regulator init/probing/exit functions
+ */
+static int tps6518x_regulator_probe(struct platform_device *pdev)
+{
+	struct tps6518x *tps6518x = dev_get_drvdata(pdev->dev.parent);
+	struct tps6518x_platform_data *pdata = tps6518x->pdata;
+	struct tps6518x_data *priv;
+	struct regulator_dev **rdev;
+	struct regulator_config config = { };
+	int size, i, ret = 0;
+
+    printk("tps6518x_regulator_probe starting\n");
+
+	if (tps6518x->dev->of_node) {
+		ret = tps6518x_pmic_dt_parse_pdata(pdev, pdata);
+		if (ret)
+			return ret;
+	}
+	priv = devm_kzalloc(&pdev->dev, sizeof(struct tps6518x_data),
+			       GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	size = sizeof(struct regulator_dev *) * pdata->num_regulators;
+	priv->rdev = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);
+	if (!priv->rdev)
+		return -ENOMEM;
+
+	rdev = priv->rdev;
+	priv->num_regulators = pdata->num_regulators;
+	platform_set_drvdata(pdev, priv);
+
+	tps6518x->vcom_setup = false;
+	tps6518x->pass_num = tps6518x_pass_num;
+	tps6518x->vcom_uV = tps6518x_vcom;
+
+	for (i = 0; i < pdata->num_regulators; i++) {
+		int id = pdata->regulators[i].id;
+
+		config.dev = tps6518x->dev;
+		config.init_data = pdata->regulators[i].initdata;
+		config.driver_data = tps6518x;
+		config.of_node = pdata->regulators[i].reg_node;
+
+		rdev[i] = regulator_register(&tps6518x_reg[id], &config);
+		if (IS_ERR(rdev[i])) {
+			ret = PTR_ERR(rdev[i]);
+			dev_err(&pdev->dev, "regulator init failed for %d\n",
+					id);
+			rdev[i] = NULL;
+			goto err;
+		}
+	}
+
+	/*
+	 * Set up PMIC timing values.
+	 * Should only be done one time!  Timing values may only be
+	 * changed a limited number of times according to spec.
+	 */
+	tps6518x_setup_timings(tps6518x);
+
+    printk("tps6518x_regulator_probe success\n");
+	return 0;
+err:
+	while (--i >= 0)
+		regulator_unregister(rdev[i]);
+	return ret;
+}
+
+static int tps6518x_regulator_remove(struct platform_device *pdev)
+{
+	struct tps6518x_data *priv = platform_get_drvdata(pdev);
+	struct regulator_dev **rdev = priv->rdev;
+	int i;
+	printk ("tps6518x_ Unregistred regulador \n");
+	for (i = 0; i < priv->num_regulators; i++)
+		regulator_unregister(rdev[i]);   //
+	return 0;
+}
+
+static const struct platform_device_id tps6518x_pmic_id[] = {
+	{ "tps6518x-pmic", 0},
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(platform, tps6518x_pmic_id);
+
+static struct platform_driver tps6518x_regulator_driver = {
+	.probe = tps6518x_regulator_probe,
+	.remove = tps6518x_regulator_remove,
+	.id_table = tps6518x_pmic_id,
+	.driver = {
+		.name = "tps6518x-pmic",
+	},
+};
+
+static int __init tps6518x_regulator_init(void)
+{
+	return platform_driver_register(&tps6518x_regulator_driver);
+}
+subsys_initcall_sync(tps6518x_regulator_init);
+
+static void __exit tps6518x_regulator_exit(void)
+{
+	platform_driver_unregister(&tps6518x_regulator_driver);
+}
+module_exit(tps6518x_regulator_exit);
+
+
+/*
+ * Parse user specified options (`tps6518x:')
+ * example:
+ *   tps6518x:pass=2,vcom=-1250000 (uV) -1.25V
+ */
+static int __init tps6518x_setup(char *options)
+{
+	int ret;
+	char *opt;
+	unsigned long ulResult;
+	printk("tps6518x_ _init tps65185 Options= %s \n",options);//tps6518x_ _init tps65185 Options= pass=5,vcom=-1250000 	
+	while ((opt = strsep(&options, ",")) != NULL) {
+		if (!*opt)
+			continue;
+		if (!strncmp(opt, "pass=", 5)) {
+			ret = kstrtoul((const char *)(opt + 5), 0, &ulResult);
+			tps6518x_pass_num = ulResult;
+			printk("tps6518x_ tps6518x_pass_num=%u \n",tps6518x_pass_num);//tps6518x_ tps6518x_pass_num=5 
+			if (ret < 0)
+				return ret;
+		}
+		if (!strncmp(opt, "vcom=", 5)) {
+			int offs = 5;
+			if (opt[5] == '-')
+				offs = 6;
+			ret = kstrtoul((const char *)(opt + offs), 0, &ulResult);
+			tps6518x_vcom = (int) ulResult;
+			if (ret < 0)
+				return ret;
+			tps6518x_vcom = -tps6518x_vcom;
+			printk("tps6518x_ tps6518x_vcom= %u \n",tps6518x_vcom);//tps6518x_ tps6518x_vcom= 4293717296
+		}
+	}
+
+	return 1;
+}
+
+__setup("tps6518x:", tps6518x_setup);
+
+static int __init tps65182_setup(char *options)
+{
+	int ret;
+	char *opt;
+	unsigned long ulResult;
+	printk("tps6518x_ _init tps65182 Options= %s ",options); 
+	while ((opt = strsep(&options, ",")) != NULL) {
+		if (!*opt)
+			continue;
+		if (!strncmp(opt, "pass=", 5)) {
+			ret = kstrtoul((const char *)(opt + 5), 0, &ulResult);
+			tps6518x_pass_num = ulResult;
+			if (ret < 0)
+				return ret;
+		}
+		if (!strncmp(opt, "vcom=", 5)) {
+			int offs = 5;
+			if (opt[5] == '-')
+				offs = 6;
+			ret = kstrtoul((const char *)(opt + offs), 0, &ulResult);
+			tps6518x_vcom = (int) ulResult;
+			if (ret < 0)
+				return ret;
+			tps6518x_vcom = -tps6518x_vcom;
+		}
+	}
+
+	return 1;
+}
+
+__setup("tps65182:", tps65182_setup);
+
+
+/* Module information */
+MODULE_DESCRIPTION("TPS6518x regulator driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/fbdev/mxc/mxc_epdc_v2_fb.c b/drivers/video/fbdev/mxc/mxc_epdc_v2_fb.c
index bdbf005..c328a49 100644
--- a/drivers/video/fbdev/mxc/mxc_epdc_v2_fb.c
+++ b/drivers/video/fbdev/mxc/mxc_epdc_v2_fb.c
@@ -51,7 +51,7 @@
 #include <linux/mfd/syscon.h>
 #include <linux/regmap.h>
 #include <linux/regulator/driver.h>
-#include <linux/mfd/max17135.h>
+#include <linux/mfd/tps6518x.h>		 /* BombShell V2 */	
 #include <linux/fsl_devices.h>
 #include <linux/bitops.h>
 #include <linux/pinctrl/consumer.h>
@@ -814,7 +814,8 @@ static inline void epdc_set_temp(u32 temp)
 	unsigned int ext_temp, ext_temp_index = temp;
 
 	if (temp == DEFAULT_TEMP_INDEX) {
-		ret = max17135_reg_read(REG_MAX17135_EXT_TEMP, &ext_temp);
+		//ret = max17135_reg_read(REG_MAX17135_EXT_TEMP, &ext_temp);
+		//ret = tps6518x_reg_read(REG_TPS6518x_TMST_VAL, &ext_temp);     /*  BombShell V2  */		
 		if (ret == 0) {
 			ext_temp = ext_temp >> 8;
 			dev_dbg(g_fb_data->dev, "the current external temperature is %d\n",
diff --git a/include/linux/earlysuspend.h b/include/linux/earlysuspend.h
new file mode 100644
index 0000000..7a57439
--- /dev/null
+++ b/include/linux/earlysuspend.h
@@ -0,0 +1,52 @@
+/* include/linux/earlysuspend.h
+	
+	choreado de => https://android.googlesource.com/kernel/samsung/+/android-samsung-3.0-jb/include/linux/
+ *
+ * Copyright (C) 2007-2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _LINUX_EARLYSUSPEND_H
+#define _LINUX_EARLYSUSPEND_H
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/list.h>
+#endif
+/* The early_suspend structure defines suspend and resume hooks to be called
+ * when the user visible sleep state of the system changes, and a level to
+ * control the order. They can be used to turn off the screen and input
+ * devices that are not used for wakeup.
+ * Suspend handlers are called in low to high level order, resume handlers are
+ * called in the opposite order. If, when calling register_early_suspend,
+ * the suspend handlers have already been called without a matching call to the
+ * resume handlers, the suspend handler will be called directly from
+ * register_early_suspend. This direct call can violate the normal level order.
+ */
+enum {
+	EARLY_SUSPEND_LEVEL_BLANK_SCREEN = 50,
+	EARLY_SUSPEND_LEVEL_STOP_DRAWING = 100,
+	EARLY_SUSPEND_LEVEL_DISABLE_FB = 150,
+};
+struct early_suspend {
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	struct list_head link;
+	int level;
+	void (*suspend)(struct early_suspend *h);
+	void (*resume)(struct early_suspend *h);
+#endif
+};
+#ifdef CONFIG_HAS_EARLYSUSPEND
+void register_early_suspend(struct early_suspend *handler);
+void unregister_early_suspend(struct early_suspend *handler);
+#else
+#define register_early_suspend(handler) do { } while (0)
+#define unregister_early_suspend(handler) do { } while (0)
+#endif
+#endif
diff --git a/include/linux/ektf2k.h b/include/linux/ektf2k.h
new file mode 100644
index 0000000..8857d5a
--- /dev/null
+++ b/include/linux/ektf2k.h
@@ -0,0 +1,34 @@
+#ifndef _LINUX_ELAN_KTF2K_H
+#define _LINUX_ELAN_KTF2K_H
+/*
+#if (defined(CONFIG_7564C_V10))
+#define ELAN_X_MAX 	2112	
+#define ELAN_Y_MAX	1600	
+#else
+#define ELAN_X_MAX 	2624  	
+#define ELAN_Y_MAX	1644	
+#endif
+*/
+
+#define ELAN_X_MAX      2112
+#define ELAN_Y_MAX      1600
+
+
+/* project SMB-b7006 use this function */
+//#define   MODE_VALID_CHECK_FUNCTION
+
+#define ELAN_KTF2K_NAME "elan-ktf2k"
+
+struct elan_ktf2k_i2c_platform_data {
+	uint16_t version;
+	int abs_x_min;
+	int abs_x_max;
+	int abs_y_min;
+	int abs_y_max;
+	int intr_gpio;
+	int reset_gpio;
+        int mode_check_gpio;
+	int (*power)(int on);
+};
+
+#endif /* _LINUX_ELAN_KTF2K_H */
diff --git a/include/linux/mfd/tps6518x.h b/include/linux/mfd/tps6518x.h
new file mode 100644
index 0000000..b765c9b
--- /dev/null
+++ b/include/linux/mfd/tps6518x.h
@@ -0,0 +1,357 @@
+/*
+ * Copyright (C) 2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+#ifndef __LINUX_REGULATOR_TPS6518x_H_
+#define __LINUX_REGULATOR_TPS6518x_H_
+
+/*
+ * EPDC PMIC I2C address
+ * PAPYRUS II 1p1 and later uses 0x68, others 0x48
+ */
+#define EPDC_PMIC_I2C_ADDR 0x68
+
+/*
+ * currently supported rev IDs
+ */
+//#define TPS65180_PASS1 0x54
+//#define TPS65181_PASS1 0x55
+#define TPS65180_PASS1 0x50
+#define TPS65181_PASS1 0x51
+#define TPS65180_PASS2 0x60
+#define TPS65181_PASS2 0x61
+#define TPS65185_PASS0 0x45
+#define TPS65186_PASS0 0x46
+#define TPS65185_PASS1 0xFB		/* Bombshell V2 HW */ 
+#define TPS65186_PASS1 0x56
+#define TPS65185_PASS2 0x65
+#define TPS65186_PASS2 0x66
+
+/*
+ * PMIC Register Addresses
+ */
+enum {
+    REG_TPS6518x_TMST_VAL = 0x0,
+    REG_TPS65185_ENABLE,
+    REG_TPS65185_VADJ,
+    REG_TPS65185_VCOM1,
+    REG_TPS65185_VCOM2,
+    REG_TPS65185_INT_EN1,
+    REG_TPS65185_INT_EN2,
+    REG_TPS65185_INT1,
+    REG_TPS65185_INT2,
+    REG_TPS65185_UPSEQ0,
+    REG_TPS65185_UPSEQ1,
+    REG_TPS65185_DWNSEQ0,
+    REG_TPS65185_DWNSEQ1,
+    REG_TPS65185_TMST1,
+    REG_TPS65185_TMST2,
+    REG_TPS6518x_PG,
+    REG_TPS6518x_REVID,
+    TPS6518x_REG_NUM,
+};
+
+enum {
+    REG_TPS65180_TMST_VAL = 0x0,
+    REG_TPS65180_ENABLE,
+    REG_TPS65180_VP_ADJUST,
+    REG_TPS65180_VN_ADJUST,
+    REG_TPS65180_VCOM_ADJUST,
+    REG_TPS65180_INT_EN1,
+    REG_TPS65180_INT_EN2,
+    REG_TPS65180_INT1,
+    REG_TPS65180_INT2,
+    REG_TPS65180_PWRSEQ0,
+    REG_TPS65180_PWRSEQ1,
+    REG_TPS65180_PWRSEQ2,
+    REG_TPS65180_TMST_CONFIG,
+    REG_TPS65180_TMST_OS,
+    REG_TPS65180_TMST_HYST,
+    REG_TPS65180_PG_STATUS,
+    REG_TPS65180_REVID,
+    REG_TPS65180_FIX_READ_PTR,
+    TPS65180_REG_NUM,
+};
+
+#define TPS6518x_MAX_REGISTER   0xFF
+
+/*
+ * Bitfield macros that use rely on bitfield width/shift information.
+ */
+#define BITFMASK(field) (((1U << (field ## _WID)) - 1) << (field ## _LSH))
+#define BITFVAL(field, val) ((val) << (field ## _LSH))
+#define BITFEXT(var, bit) ((var & BITFMASK(bit)) >> (bit ## _LSH))
+
+/*
+ * Shift and width values for each register bitfield
+ */
+/* TMST_VALUE */
+#define TMST_VALUE_LSH  0
+#define TMST_VALUE_WID  8
+/* ENABLE */
+#define ACTIVE_LSH      7
+#define ACTIVE_WID      1
+#define STANDBY_LSH     6
+#define STANDBY_WID     1
+#define V3P3_SW_EN_LSH  5
+#define V3P3_SW_EN_WID  1
+#define VCOM_EN_LSH     4
+#define VCOM_EN_WID     1
+#define VDDH_EN_LSH     3
+#define VDDH_EN_WID     1
+#define VPOS_EN_LSH     2
+#define VPOS_EN_WID     1
+#define VEE_EN_LSH      1
+#define VEE_EN_WID      1
+#define VNEG_EN_LSH     0
+#define VNEG_EN_WID     1
+/* VCOM_ADJUST */
+#define VCOM_SET_LSH    0
+#define VCOM_SET_WID    8
+#define VCOM1_SET_LSH   0
+#define VCOM1_SET_WID   8
+#define VCOM2_SET_LSH   0
+#define VCOM2_SET_WID   1 //8
+#define VCOM_ACQ_LSH	15 //7
+#define VCOM_ACQ_WID	1
+#define VCOM_PROG_LSH	14 //6
+#define VCOM_PEOG_WID	1
+#define VCOM_HiZ_LSH	13 //5
+#define VCOM_HiZ_WID	1
+#define VCOM_AVG_LSH	11 //3
+#define VCOM_AVG_WID	2
+/* INT_ENABLE1 */
+#define TSD_EN_LSH        6
+#define TSD_EN_WID        1
+#define HOT_EN_LSH        5
+#define HOT_EN_WID        1
+#define TMST_HOT_EN_LSH   4
+#define TMST_HOT_EN_WID   1
+#define TMST_COOL_EN_LSH  3
+#define TMST_COOL_EN_WID  1
+#define UVLO_EN_LSH       2
+#define UVLO_EN_WID       1
+/* INT_ENABLE2 */
+#define VB_UV_EN_LSH      7
+#define VB_UV_EN_WID      1
+#define VDDH_UV_EN_LSH    6
+#define VDDH_UV_EN_WID    1
+#define VN_UV_EN_LSH      5
+#define VN_UV_EN_WID      1
+#define VPOS_UV_EN_LSH    4
+#define VPOS_UV_EN_WID    1
+#define VEE_UV_EN_LSH     3
+#define VEE_UV_EN_WID     1
+#define VNEG_UV_EN_LSH    1
+#define VNEG_UV_EN_WID    1
+#define EOC_EN_LSH        0
+#define EOC_EN_WID        1
+/* INT_STATUS1 */
+#define TSDN_LSH        6
+#define TSDN_WID        1
+#define HOT_LSH         5
+#define HOT_WID         1
+#define TMST_HOT_LSH    4
+#define TMST_HOT_WID    1
+#define TMST_COOL_LSH   3
+#define TMST_COOL_WID   1
+#define UVLO_LSH        2
+#define UVLO_WID        1
+/* INT_STATUS2 */
+#define VB_UV_LSH       7
+#define VB_UV_WID       1
+#define VDDH_UV_LSH     6
+#define VDDH_UV_WID     1
+#define VN_UV_LSH       5
+#define VN_UV_WID       1
+#define VPOS_UV_LSH     4
+#define VPOS_UV_WID     1
+#define VEE_UV_LSH      3
+#define VEE_UV_WID      1
+#define VNEG_UV_LSH     1
+#define VNEG_UV_WID     1
+#define EOC_LSH         0
+#define EOC_WID         1
+/* PWR_SEQ0 */
+#define VDDH_SEQ_LSH    6
+#define VDDH_SEQ_WID    2
+#define VPOS_SEQ_LSH    4
+#define VPOS_SEQ_WID    2
+#define VEE_SEQ_LSH     2
+#define VEE_SEQ_WID     2
+#define VNEG_SEQ_LSH    0
+#define VNEG_SEQ_WID    2
+/* PWR_SEQ1 */
+#define DLY1_LSH    4
+#define DLY1_WID    4
+#define DLY0_LSH    0
+#define DLY0_WID    4
+/* PWR_SEQ2 */
+#define DLY3_LSH    4
+#define DLY3_WID    4
+#define DLY2_LSH    0
+#define DLY2_WID    4
+/* TMST_CONFIG */
+#define READ_THERM_LSH      7
+#define READ_THERM_WID      1
+#define CONV_END_LSH        5
+#define CONV_END_WID        1
+#define FAULT_QUE_LSH       3
+#define FAULT_QUE_WID       2
+#define FAULT_QUE_CLR_LSH   2
+#define FAULT_QUE_CLR_WID   1
+/* TMST_OS */
+#define TMST_HOT_SET_LSH    0
+#define TMST_HOT_SET_WID    8
+/* TMST_HYST */
+#define TMST_COOL_SET_LSH   0
+#define TMST_COOL_SET_WID   8
+/* PG_STATUS */
+#define VB_PG_LSH       7
+#define VB_PG_WID       1
+#define VDDH_PG_LSH     6
+#define VDDH_PG_WID     1
+#define VN_PG_LSH       5
+#define VN_PG_WID       1
+#define VPOS_PG_LSH     4
+#define VPOS_PG_WID     1
+#define VEE_PG_LSH      3
+#define VEE_PG_WID      1
+#define VNEG_PG_LSH     1
+#define VNEG_PG_WID     1
+/* REVID */
+#define MJREV_LSH       6
+#define MJREV_WID       2
+#define MNREV_LSH       4
+#define MNREV_WID       2
+#define VERSION_LSH     0
+#define VERSION_WID     4
+/* FIX_READ_POINTER */
+#define FIX_RD_PTR_LSH  0
+#define FIX_RD_PTR_WID  1
+
+/*
+ * VCOM Definitions
+ *
+ * The register fields accept voltages in the range 0V to -2.75V, but the
+ * VCOM parametric performance is only guaranteed from -0.3V to -2.5V.
+ */
+#define TPS65180_VCOM_MIN_uV   -2750000
+#define TPS65180_VCOM_MAX_uV          0
+#define TPS65180_VCOM_MIN_SET         0
+#define TPS65180_VCOM_MAX_SET       255
+#define TPS65180_VCOM_BASE_uV     10740
+#define TPS65180_VCOM_STEP_uV     10740
+#define TPS65185_VCOM_MIN_uV   -5110000
+#define TPS65185_VCOM_MAX_uV          0
+#define TPS65185_VCOM_MIN_SET         0
+#define TPS65185_VCOM_MAX_SET       511
+#define TPS65185_VCOM_BASE_uV     10000
+#define TPS65185_VCOM_STEP_uV     10000
+
+
+
+#define TPS6518x_VCOM_MIN_VAL         0
+#define TPS6518x_VCOM_MAX_VAL       255
+
+struct regulator_init_data;
+
+struct tps6518x {
+	/* chip revision */
+	int revID;
+
+	struct device *dev;
+	struct tps6518x_platform_data *pdata;
+
+	/* Platform connection */
+	struct i2c_client *i2c_client;
+
+	/* Timings */
+	unsigned int pwr_seq0;
+	unsigned int pwr_seq1;
+	unsigned int pwr_seq2;
+	unsigned int upseq0;
+	unsigned int upseq1;
+	unsigned int dwnseq0;
+	unsigned int dwnseq1;
+
+	/* GPIOs */
+	int gpio_pmic_pwrgood;
+	int gpio_pmic_vcom_ctrl;
+	int gpio_pmic_wakeup;
+	int gpio_pmic_intr;
+	int gpio_pmic_powerup;
+
+	/* TPS6518x part variables */
+	int pass_num;
+	int vcom_uV;
+
+	/* One-time VCOM setup marker */
+	bool vcom_setup;
+
+	/* powerup/powerdown wait time */
+	int max_wait;
+
+	/* Dynamically determined polarity for PWRGOOD */
+	int pwrgood_polarity;
+};
+
+enum {
+    /* In alphabetical order */
+    TPS6518x_DISPLAY, /* virtual master enable */
+    TPS6518x_VCOM,
+    TPS6518x_V3P3,
+    TPS6518x_NUM_REGULATORS,
+};
+
+/*
+ * Declarations
+ */
+struct regulator_init_data;
+struct tps6518x_regulator_data;
+
+struct tps6518x_platform_data {
+	unsigned int pwr_seq0;
+	unsigned int pwr_seq1;
+	unsigned int pwr_seq2;
+	unsigned int upseq0;
+	unsigned int upseq1;
+	unsigned int dwnseq0;
+	unsigned int dwnseq1;
+	int gpio_pmic_pwrgood;
+	int gpio_pmic_vcom_ctrl;
+	int gpio_pmic_wakeup;
+	int gpio_pmic_intr;
+	int gpio_pmic_powerup;
+	int pass_num;
+	int vcom_uV;
+
+	/* PMIC */
+	struct tps6518x_regulator_data *regulators;
+	int num_regulators;
+};
+
+struct tps6518x_regulator_data {
+	int id;
+	struct regulator_init_data *initdata;
+	struct device_node *reg_node;
+};
+
+int tps6518x_reg_read(int reg_num, unsigned int *reg_val);
+int tps6518x_reg_write(int reg_num, const unsigned int reg_val);
+
+#endif
-- 
2.1.4

